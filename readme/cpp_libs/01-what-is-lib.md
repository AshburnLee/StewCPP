## 1. 什么是链接库


有些文件专门用于存储可以重复使用的代码块，例如功能实用的函数或者类，我们通常将它们称为库文件，简称“库”（Library）。

以 C 语言为例，如下为大家展示的就是一个函数库：

~~~cpp
//myMath.c
int add(int a, int b) {
    return  a + b;
}
... // 其他函数
~~~

显然，实际开发中引入他人编写好的库文件可以省略某些功能的开发环节，提高项目的开发效率。但遗憾的是，类似 myMath.c 这种“开源”的库文件很难找到，多数程序员并不会直接分享源代码，他们更愿意**分享库文件的二进制版本一一一链接库**。

所谓链接库，其实就是将开源的库文件（例如上面提到的 myMath.c）进行**编译、打包**操作后得到的**二进制文件**。虽然链接库是二进制文件，但无法独立运行，必须等待其它程序调用，才会被载入内存。

一个完整的 C 语言项目可能包含多个 .c 源文件，项目的运行需要经过“编译”和“链接”两个过程： 

- 编译：由编译器**逐个对源文件**做**词法分析、语法分析、语义分析**等操作，最终生成**多个目标文件**。每个目标文件都是**二进制文件**，但由于它们会相互调用对方的函数或变量，还可能会调用某些链接库文件中的函数或变量，**编译器无法跨文件找到它们确切的存储地址，所以这些目标文件无法单独执行**。

- 链接：对于各个目标文件中缺失的函数和变量的存储地址【后续简称“缺失的地址”： 引用的符号（函数或变量）在当前目标文件中的地址未知， 这些符号在编译阶段被编译器标记为外部引用】，由链接器负责修复，并最终将所有的目标文件和链接库组织成一个**可执行文件**。

注意，一个目标文件中使用的函数或变量，可能定义在其他的目标文件中，也可能定义在某个链接库文件中。

## 2. 链接器完成完成链接工作的方式有两种

- 静态链接: 链接器将目标文件（.o 或 .obj 文件）和库文件中的所有必要代码和数据**直接复制到最终的可执行文件中**。 这意味着可执行文件包含了运行**所需的一切，无需依赖外部库**。 静态链接的优点是可执行文件独立运行，无需外部依赖；缺点是可执行文件**体积较大**，占用更多磁盘空间和内存，并且如果库更新，需要**重新链接**才能使用新版本。

- 动态链接: 链接器只将目标文件和库文件中的**必要信息**（例如函数地址）写入可执行文件，而实际的代码和数据仍然保留在动态链接库（DLL 或 .so 文件）中。 程序运行时，操作系统加载器会加载必要的动态链接库，并将可执行文件中的引用与库中的实际代码连接起来。动态链接的优点是可执行文件**体积较小**，节省磁盘空间和内存，并且库更新后，**所有使用该库的程序都能自动受益**；缺点是程序运行时依赖于动态链接库的存在，如果库缺失或版本不兼容，程序可能无法运行（所谓的“DLL地狱”）。

## 3. 静态链接库和动态链接库

也就是说，程序完成链接操作的方式有两种，一种是在生成可执行文件之前完成所有链接操作，使用的库文件称为静态链接库；另一种是将部分链接操作推迟到程序执行时才进行，此过程使用的库文件称为动态链接库。 

### 静态链接库

静态链接库用来和所有的目标文件一起组织成可执行文件，生成的可执行文件可以独立运行。

采用静态链接库完成链接操作，存在诸多<font color=red>缺点</font>。
- 首先，【空间浪费】可执行文件内部拷贝了所有目标文件和静态链接库的指令和数据，文件本身的体积会很大。当系统中存在多个 链接到同一个静态库的可执行文件时，每个可执行文件中都存有一份静态库的指令和数据，就会造成内存空间的极大浪费。【重复拷贝了许多指令和数据】
- 此外，【库更新困难】一旦程序中有模块更新，整个程序就必须<font color=red>重新链接</font>后才能运行。假设一个程序有 20 个模块构成，每个模块的大小为 1 MB，那么每次更新任何一个模块，用户就必须重新获取 20 MB 的程序，对用户很不友好。


### 动态链接库

实际上，动态链接库是 Windows 平台上对动态链接过程所用库文件的称谓，Linux 平台上习惯称为<font color=blue>共享库</font>或者<font color=blue>共享对象文件</font>，它们表达的是一个意思。

所谓动态链接，指的是将链接的时机推迟到程序**运行时**再进行。具体来讲，对于一个以动态链接方式运行的项目，首先由静态链接器将所有的目标文件组织成一个可执行文件，运行时将所需的动态链接库全部载入内存，由动态链接器完成可执行文件和动态库文件的链接工作。

动态链接库可以跟着可执行文件一同载入内存，也可以在可执行文件运行过程中载入，即可执行文件什么时候需要，动态链接库才会载入内存。

<font color=red>优势</font>：和静态链接库相比，动态链接库可以很好地解决空间浪费和更新困难的问题：
- 【一套库指令和数据】动态链接库和可执行文件是分别载入内存的，因此动态链接库的体积通常会小一些。当有多个程序**使用同一个动态链接库时**，所有程序可以**共享一份动态链接库的指令和数据**，避免了空间的浪费。

- 【库单独更新】采用动态链接的方式也可以**方便**程序的更新和升级，当程序的某个模块更新后，只需要将旧的模块替换掉，程序运行时会自动将所有模板载入内存并动态地链接在一起。

那么采用动态链接的方式，每次程序运行时都i要重新连接，会不会很慢，的确，冬天链接库确实会损失一部分性能，但是世家证明，动态链接库和静态链接库相比，性能损失大约在5% 一下，由此换取程序在空间上的节省以及更新时的便利，是相当值得的。


## 补：链接器如何修复缺失的地址？

- 符号解析 (Symbol Resolution): 链接器首先扫描所有输入的目标文件和库文件，收集所有定义的符号（函数和变量）及其地址。 这包括从目标文件中的符号表中提取信息。
- 符号查找 (Symbol Lookup): 链接器根据目标文件中未定义的符号（外部引用），在已收集的**符号表**中查找匹配的定义。如果找到匹配的定义，链接器就知道了该符号的地址。
- 重定位 (Relocation): 一旦链接器找到了所有未定义符号的地址，它就需要**修改目标文件中的代码和数据**，将未定义符号的引用替换为其实际地址。这个过程称为重定位。 重定位需要修改指令中的操作数或数据段中的地址。
- 地址空间分配 (Address Space Allocation): 链接器需要为所有输入的目标文件和库文件分配地址空间。 它会决定每个目标文件和库文件在最终可执行文件中的起始地址和大小。 这需要考虑内存对齐、段的组织等因素。
- 生成可执行文件 (Executable Generation): 最后，链接器将所有目标文件和库文件组合在一起，并根据地址空间分配的结果，生成一个完整的可执行文件。 这个可执行文件包含了所有必要的代码、数据和元数据，可以被操作系统加载并执行。
