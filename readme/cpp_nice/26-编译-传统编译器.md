
1. SSO 优化
2. 什么是翻译单元
3. volatile 告诉编译器不要做优化

===

## 小型字符串优化 (Small String Optimization, SSO)  [底层优化]

现象是 :

~~~cpp
std::string a = "abc";
sizeof(a);   // 32
sizeof(std::String);  // 32 
~~~

`sizeof` 是编译时的运算符，不考虑实际值。 32 这并非一个固定的值，它取决于编译器、标准库实现和系统架构。

许多 `std::string` 实现都使用了 SSO 技术来优化内存使用。SSO 的核心思想是：如果字符串很短，则直接在 `std::string` 对象内部分配一个**固定大小**的字符数组来存储字符串内容，避免动态内存分配的开销。只有当字符串长度超过这个预分配的缓冲区大小后，才会动态分配内存。


## 翻译单元

Translation Unit：的是编译器实际编译的代码单元。它不是你编写的单个 .cpp 文件，而是由**预处理器**处理后形成的一个完整的代码实体。 更通俗地说，它是一个经过预处理后的、准备交给编译器进行编译的代码单元。

以下是翻译单元的构成：

1. 一个 .cpp 文件: 翻译单元的基础是一个 .cpp (或 .cc, .cxx) 源文件。
2. 包含的头文件: 该 .cpp 文件中所有 `#include` 指令包含的头文件的内容都会被添加到翻译单元中。这包括直接包含的头文件以及间接包含的头文件（即，头文件包含其他头文件）。
3. 预处理指令: 预处理器指令（例如 `#define`, `#ifdef`, `#ifndef`, `#endif` 等）会被预处理器处理，其结果会影响最终的翻译单元内容。 被条件编译指令（例如 `#ifdef`）排除的代码不会包含在翻译单元中。

## One-stop header

是一种编程实践，指的是一个头文件中包含了某个库或框架的所有必要头文件。通过包含这个单一的头文件，开发者可以访问库或框架的所有功能，而不需要逐个包含多个头文件。这种做法简化了代码的编写和维护，特别是在大型项目中。

一些 one-stop header：
~~~cpp
#include <torch/script.h>
#include <Eigen/Dense>
#include <boost/algorithm/string.hpp> //包含了Boost库中所有与字符串处理相关的头文件。
#include <opencv2/opencv.hpp> //包含了openCV 中的主要功能的头文件
~~~


## volatile   [一般不使用]

背景：编译器优化常用的方法有：将内存变量缓存到寄存器。

编译器在存取变量时，为提高存取速度，编译器优化有时会先把变量读取到一个寄存器中；以后再取变量值时就直接从寄存器中取值。**但在很多情况下会读取到脏数据**，严重影响程序的运行效果。

所以：

`volatile` 提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，**告诉编译器对该变量不做优化**，都会直接从变量内存地址中读取数据，从而可以提供对特殊地址的稳定访问。如果没有 `volatile` 关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。（简洁的说就是： `volatile` 关键词影响编译器编译的结果，用 `volatile` 声明的变量表示该变量随时可能发生变化，与该变量有关的运算，不要进行编译优化，以免出错。

`volatile` 关键字主要用于处理与硬件或多线程相关的特殊情况。在大多数情况下，不需要使用 `volatile` 。 不当使用 `volatile` 可能会降低程序性能，因为它会阻止编译器进行一些重要的优化。 只有在确信需要防止编译器优化时才应该使用它。 

