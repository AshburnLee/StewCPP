
本节内容需混乱，有误，需要从新整理

===

## 编译器可能使用指针来 实现 左值引用

~~~cpp
int a = 9;
int& r = a;
~~~

变量一定是要占用内存的，对引用变量 r 取地址也应该得到 r 的地址，但实际上却是 a 的地址->疑问

看下边的例子：

~~~cpp
int num = 99;

class A {
public:
    A();
private:
    int m_n;
    int& m_r;
};
A::A():m_n(0), m_r(num) {}

void Test1() {
    A* a = new A();
    //输出 A 类型的大小
    cout << sizeof(A) << endl;
    //输出 r 本身的内容
    cout << hex << showbase << *((int*)a + 1) << endl; 
    // 输出 num 的地址
    cout << &num <<endl; 
    return;
}
~~~

从执行结果看：

- m_r 是占内存的，也是8字节（int在64bit系统占8字节）
- m_r 的内容是 num 的地址

这与指针的行为一样。如果将m_r类型换为指针，并指向num：

~~~cpp
int* m_r = num;
~~~

那么结果是：

- m_r 是占内存的，也是8字节（int在64bit系统占8字节）
- m_r 的内容是 num 的地址

所以：引用的**本质就是指针，是指针简单的封装**。所以对上面的疑问，为啥取不到引用变量的地址呢? 是因为编译器进行了内部转换.

================================ 需要验证

对于下面的代码：
~~~cpp
    int a = 99;
    int &r = a;
    r = 18;
    cout<<&r<<endl;
~~~

编译器会转化为：

~~~cpp
    int a = 99;
    int *r = &a;
    *r = 18;
    cout<<r<<endl;
~~~

使用`&r`取地址时，编译器会对代码进行隐式的转换，使得代码输出的是 `r` 的内容（`a` 的地址），而不是 `r` 的地址，这就是为什么获取不到引用变量的地址的原因。也就是说，不是变量 `r` 不占用内存，而是编译器不让获取它的地址。***

====================================

当引用作为函数参数时，也会有类似的转换：

~~~cpp
    //定义函数
    void swap(int &r1, int &r2){
        int temp = r1;
        r1 = r2;
        r2 = temp;
    }
    //调用函数
    int num1 = 10, num2 = 20;
    swap(num1, num2);
~~~

编译时会被转换成如下的形式：

~~~cpp
    //定义函数
    void swap(int *r1, int *r2){
        int temp = *r1;
        *r1 = *r2;
        *r2 = temp;
    }
    //调用函数
    int num1 = 10, num2 = 20;
    swap(&num1, &num2);
~~~

引用虽然是基于指针实现的，但它比指针更加易用，从上面的两个例子也可以看出来，通过指针获取数据时需要加`*`，书写麻烦（看函数体），而引用不需要，它和普通变量的使用方式一样。

C++ 的发明人 Bjarne Stroustrup 也说过，他在 C++ 中引入引用的直接目的是为了**让代码的书写更加漂亮**，尤其是**在运算符重载**中，不借助引用有时候会使得运算符的使用很麻烦。 


## 引用和指针的其他区别

二者不同：

- 引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。

- 可以有 const 指针，但是没有 const 引用。也就是说，引用变量不能定义为下面的形式：

    ~~~cpp
    int a = 20;
    int& const r = a;
    ~~~

    第二句话，const 引用 r，意味着 r 本身不能被重新绑定到另一个变量。在 C++ 中总是需要被初始化，并且**一旦初始化，就不能再引用其他对象**。加上 const 是多此一举。但你可以这样用：

    ~~~cpp
    int const& r = a;  // 表示r引用的int 不能别改变？
    ~~~

- 指针可以有多级，但是引用只能有一级，例如，`int **p` 是合法的，而 `int &&r` 是不合法的。如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个&，如下所示：

    ~~~cpp
    int a = 10;
    int &r = a;
    int &rr = r;
    ~~~

- 指针和引用的自增（++）自减（--）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1。
