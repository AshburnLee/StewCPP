
1. 按指针传递，也有一次拷贝，拷贝一个指针。
2. 函数返回值优化。

=== 

## 函数传参

- **按引用传递**是函数内部修改参数会改变外部变量值的主要方式。 当使用引用传递时，函数参数成为外部变量的别名，因此对参数的任何修改都会直接反映到外部变量上。***

- **按指针传递**也可以达到同样的效果，**前提是函数内部修改的是指针指向的值，而不是指针本身。 如果函数内部修改了指针本身指向的地址，则外部变量的值不会改变。**  

    也就是说：按指针传递时，函数接收的是**指针的副本**。 如果函数内部修改的是**指针指向的数据**，则外部变量的值会改变；如果函数修改的是指针本身（使其指向不同的地址），则外部变量的值不会改变，因为外部变量的内存地址没有被修改。 [是的，传递指针给函数，函数接受的是指针的副本，但其指向内容与本体相同] ***

    如果函数内部**通过指针解引用**修改了指针所指向的内存地址中的内容，则会直接影响到原始变量的值。这就与按引用传递的目的一致了。


## 函数参数默认值

在C++中，定义函数时可以给形参指定一个默认的值，这样**调用函数时如果没有给这个形参赋值，那么就使用这个默认的值**。也就是说，调用函数时可以省略有默认值的参数。如果用户指定了参数的值，那么就使用用户指定的值。

C++规定，默认参数只能放在形参列表的最后，而且一旦为某个形参指定了默认值，那么它后面的所有形参都必须有默认值。实参和形参的传值是从左到右依次匹配的，默认参数的**连续性**是保证正确传参的前提。

~~~cpp
void func(int a, int b=1) {}
void func(int a, int b=1, int c=2) {}
~~~

可在函数定义处指定了默认参数。除了函数定义，你也可以在函数声明处指定默认参数。


## C++ 接受函数返回值的变量与函数体 return 临时变量是同一个对象吗？  [编译器行为]

函数返回值的变量与函数体中 return 的临时变量是否是同一个对象，取决于**编译器的优化策略**和具体的代码实现。涉及到的优化技术是返回值优化（Return Value Optimization, `RVO`）和命名返回值优化（Named Return Value Optimization, `NRVO`）。

- 返回值优化（**RVO**）: 用于消除函数返回值的临时对象拷贝。编译器在生成代码时，直接在**调用者的上下文中构造返回值对象**，而不是在函数内部构造临时对象然后再拷贝到调用者的上下文中。
- 命名返回值优化（**NRVO**）: NRVO 是 RVO 的一种特殊情况，适用于函数返回一个命名的局部变量。编译器可以直接在**调用者的上下文中构造这个命名的**局部变量，从而**避免临时对象的拷贝**。

现代 C++ 编译器（如 GCC、Clang 和 MSVC）通常会自动应用 RVO 和 NRVO 优化，但这不是强制要求的。你可以使用编译器选项来查看优化是否生效。例如，在 GCC 中，你可以使用 `-fno-elide-constructors` 选项来禁用这些优化，以观察没有优化时的行为。
