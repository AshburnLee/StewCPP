

## 随机数与分布

`std::minstd_rand` 是 C++ 标准库中的一个线性同余**随机数生成器**，用于生成伪随机数序列。`std::minstd_rand` 通常与**分布类**（如 `std::uniform_int_distribution`）结合使用，分布类用于定义**随机数的分布规律**，而 `std::minstd_rand` 用于生成随机数序列。所以通过将**随机数生成器和分布类结合使用**，可以生成符合特定分布规律的随机数序列。

- 那么一个随机数种子是做什么的？：一个随机数种子是用来初始化随机数生成器的**起始状态的值**。通过提供相同的种子，可以确保每次运行随机数生成器时生成的随机数序列是相同的，从而实现可重现的随机性。 ***

解释一个实例：

~~~cpp
std::minstd_rand msr(42); //参数 42 表示随机数生成器的种子（seed）。种子是用于初始化随机数生成器的初始值，不同的种子会导致不同的随机数序列。通过指定种子，可以控制随机数生成器生成的随机数序列，使其在不同运行中产生相同的随机数序列。
msr.discard(1);  // 它的作用是丢弃（discard）生成的前几个随机数。在这种情况下，discard(1) 表示丢弃生成的第一个随机数。
std::uniform_int_distribution<>(2, 5)(msr)  // msr的作用是生成随机数，在随机数生成中，引擎（engine）是负责生成随机数序列的组件，它定义了随机数生成的算法。不同的引擎可能采用不同的随机数生成算法，例如线性同余发生器、梅森旋转算法等。引擎的选择会影响随机数的质量、周期性和分布特性。因此，引擎的选择决定了随机数生成的方式和质量。
~~~

对应的python 实现

~~~py
import random
# 创建 Random 对象
random_gen = random.Random(42)
# 跳过第一个随机数
random_gen.randint(2, 5)
random_number = random_gen.randint(2, 5)  # uniform_int_distribution
print(random_number)
~~~

## 一个 map 对象，什么情况下会传入一个 key ，但是其 value 是空？ [先检查map中是否存在这个key是否是空]

在 C++ 的 std::map 中，当你尝试使用**operator[]**来访问一个不存在的 key 时，**会自动插入一个具有默认值的新元素**，并返回对该值的引用。如果该值的类型是类对象或结构体，则其默认构造函数将被调用来初始化该值，这可能导致该值为空或具有默认构造的状态。

要避免在 std::map 中插入空值的 key，可以使用 std::map 的 find 函数来检查 key 是否存在，然后再进行访问操作.


## `<<，>>`

左移位运算符 <<：将一个数的二进制表示向左移动指定的位数。每向左移动一位，数值就翻倍（相当于乘以2）
右移位运算符 >>：将一个数的二进制表示向右移动指定的位数。每向右移动一位，数值就减半（相当于除以2）
左移位运算符可以用来快速乘以2的幂，而右移位运算符可以用来快速除以2的幂


## `!!` 运算符

作用是将一个值(任何类型)转换为布尔值（bool 类型），并确保结果是 true 或 false。***

~~~cpp
    int a = 42;
    int b = 0;

    bool bool_a = !!a; // 将 a 转换为布尔值
    bool bool_b = !!b; // 将 b 转换为布尔值

    std::cout << "bool_a: " << bool_a << std::endl; // 输出：bool_a: 1
    std::cout << "bool_b: " << bool_b << std::endl; // 输出：bool_b: 0
~~~

解释：

`int a = 42;`:

- `a` 的值为 42，在布尔上下文中，非零值被视为 true。
- `!a` 的结果为 false（因为 42 被视为 true，取反后为 false）。
- `!!a` 的结果为 true（再次取反后为 true）。

`int b = 0;`:

- `b` 的值为 0，在布尔上下文中，零值被视为 false。
- `!b` 的结果为 true（因为 0 被视为 false，取反后为 true）。
- `!!b` 的结果为 false（再次取反后为 false）。


## 合并 Switchcase

~~~cpp
case mytype::type1:
case mytype::type2:
case mytype::type3:
    return youtype;
~~~


## Map 和 Switch case 如何取舍

Switch case
- 适用于**少量固定**的值
- 编译时做检查
- 对于少量离散值，效率更好

Map
- 动态添加，无需修改代码
- 对于大量的键值对，map使用红黑树，在查找时具有好的效率
- 但是在自定义的类型上需要特化 `std::hash`

所以，如果你是一个固定的映射，以后不会再改变，那就是用 Switch case 吧


## switch case 的坑  [{...}]

c++ switch case 编译错误：`transfer of control bypasses initialization of:` 如何处理？最佳实践，对于每一种 case，用 `{}` 包裹：

~~~cpp
case 1: {
    int variable = 10;
    // code to be executed if the case is 1
    break;
}
case 2: {
    int variable = 20;
    // code to be executed if the case is 2
    break;
}
default: {
    int variable = 0;
    // code to be executed if none of the cases match
    break;
}
~~~


## std::function  [包装任何可调用对象]

用于包装任何可调用对象（普通函数、函数对象、Lambda 表达式）, 提供一种通用的方式来存储、传递和调用这些可调用对象。用来包装**不同类型**的可调用对象，并通过**相同**的方式进行调用。这使得代码更加灵活，可以在**运行时决定调用哪个函数或函数对象**。

~~~cpp
// 一个普通函数
int add(int a, int b) {
    return a + b;
}
// 一个可调用对象（函数对象）functor
struct Multiply {
    int operator()(int a, int b) const {
        return a * b;
    }
};
int main() {
    // 使用 std::function 包装普通函数
    std::function<int(int, int)> func1 = add;
    func1(3, 4);

    // 使用 std::function 包装函数对象
    std::function<int(int, int)> func2 = Multiply();
    func2(3, 4);

    // 使用 Lambda 表达式
    std::function<int(int, int)> func3 = [](int a, int b) {
        return a - b;
    };
    func3(7, 4);
    return 0;
}
~~~

struct 同类一样，编译器会为一个 struct 生成一些成员方法。

## std::ref 在什么情况下使用   [避免开销]

`std::ref(value)` 将 `value` 的引用包装为一个可传递给函数的对象，这样可以确保 func 函数中对 `value` 的修改会影响到实际的对象，避免了不必要的拷贝开销。

`std::ref` 返回的是 `std::reference_wrapper` 对象，要访问原始对象，需要调用 `get()` 方法。

## 简化代码

~~~cpp
std::string mtag;
if (!dgraph.universal_stride_.empty()) {
    mtag = dgraph.universal_stride_;
    lt.stride_
        = memory_tag2strides(gi[lt.id_], mtag);
} else {
    lt.stride_
        = memory_tag2strides(gi[lt.id_], dgraph.lt_2_mtag_[lt.id_]);
}
~~~

简化：

~~~cpp
std::string mtag = dgraph.universal_stride_.empty() ? dgraph.lt_2_mtag_[lt.id_] : dgraph.universal_stride_;
lt.stride_ = memory_tag2strides(gi[lt.id_], mtag);
~~~

## 简化代码

~~~cpp
    if (!all_letters(stride) || !all_digit_cross(shape)) { msg = err_msge; }
    if (!all_letters(stride)) msg = tag_err_msge;
    if (!all_digit_cross(shape)) msg = shape_err_msge;
    if (!all_letters(stride) && !all_digit_cross(shape)) msg = shape_err_msge + tag_err_msge;

~~~

优化为：

~~~cpp
    std::string msg_1, msg_2;
    msg = (msg_2 = !all_digit_cross(shape) ? shape_err_msge : "")
            + (msg_1 = !all_letters(stride) ? tag_err_msge : "");
~~~


## C++ 装饰器 [lower优先级]

c++中实现类似 python 的装饰器的功能:

~~~cpp
#include <iostream>
#include <functional>

using namespace std;

// 定义一个装饰器函数，接受一个函数作为参数
template<typename Func>
auto decorator(Func f) {
    // 返回一个lambda表达式，该表达式接受任意参数并调用传入的函数
    return [=](auto... args) {
        // 在调用函数之前输出一些信息
        cout << "Before function call" << endl;
        // 调用传入的函数
        auto result = f(args...);
        // 在调用函数之后输出一些信息
        cout << "After function call" << endl;
        // 返回函数的结果
        return result;
    };
}

// 定义一个函数，用于测试装饰器
int add(int a, int b) {
    return a + b;
}

int main() {
    // 使用装饰器装饰add函数
    auto decorated_add = decorator(add);
    // 调用装饰后的函数
    cout << decorated_add(1, 2) << endl;
    return 0;
}
~~~


## 0xffffffffffffffff 当表示一个大小时，表示多少？

0xffffffffffffffff 表示一个十六进制数，它等价于十进制的 18,446,744,073,709,551,615。 它的类型取决于上下文，但最常见的是 unsigned long long 类型 64位整数。

每个十六进制数字代表 4 个二进制位。例如：

    0x0 = 0000 (二进制)
    0x1 = 0001 (二进制)
    0xF = 1111 (二进制)

每个 f 都代表 1111 (二进制)。所以它是64位二进制数。因为2⁴ = 16

## c++ 如何用 printf 打印 string 类型对象？

~~~cpp
printf("%s", myString.c_str());
~~~


## reference_wrapper [原地修改]

如何原地修改 in1 和 in2 ？

~~~cpp
int in1 = 10;
int in2 = 20;

std::vector<std::reference_wrapper<int>> inputs {in1, in2};

// 原地修改in1和in2
inputs[0].get() = 100;
inputs[1].get() = 200;
~~~

std::reference_wrapper provides an **implicit conversion to the referred type**.

## size_t 类型是无符号整数类型， [自然]

表示对象的大小或数组的索引。它不能表示负数。


## std::uintptr_t

是 C++ 中一个无符号整数类型，其大小足以存储任何有效的指针值。它的**主要功能是允许在指针和整数之间进行安全可靠的转换(比如进行地址之间的计算)**，以便进行一些需要整数运算的操作，而这些操作在指针上直接进行是不允许或不安全的。

- 指针到整数的转换: 可以将一个指向任何类型的指针安全地转换为 `std::uintptr_t` 类型。 这使得你可以对指针进行算术运算，例如位操作或模运算，这些运算在指针类型上通常是不允许的。
- 整数到指针的转换: 可以将一个 `std::uintptr_t` 类型的值安全地转换回指向 void 的指针。 然后，你可以将这个 void 指针转换为其他类型的指针，前提是你知道这个指针指向的数据类型。
- 指针比较: 虽然你可以直接比较指针，但使用 `std::uintptr_t` 可以更方便地进行指针比较，特别是当需要进行位操作或其他整数运算后进行比较时。
- 内存地址计算: 在一些底层编程中，例如内存管理或设备驱动程序，你可能需要计算内存地址。`std::uintptr_t` 提供了一种安全的方式来进行这些计算。

~~~cpp
  int x = 10;
  int* ptr = &x;

  std::uintptr_t int_representation = reinterpret_cast<std::uintptr_t>(ptr); // 使得地址值可以运算
  std::cout << "Pointer as integer: " << int_representation << std::endl;
~~~


## sizeof(n) * CHAR_BIT

表示了一个数 n 有多少位（bit）？

`CHAR_BIT` 是一个宏定义，在 `<climits>` 或 `<limits.h>` 头文件中定义，它表示一个字节（`byte`）中的位数（`bit`数）。在大多数现代计算机体系结构中，`CHAR_BIT` 的值通常是 8，意味着一个字节包含 8 位。

## C++ 中，字符类型 char 可以是带符号的（signed char）或无符号的（unsigned char）

char 和 int 的比较

存储大小和范围：

- int 通常是一个32位（或更大，取决于平台和编译器）的有符号整数，能够表示的范围远大于 char。
- char 在C和C++中通常是一个8位的字符类型，但它也可以用来存储小范围的整数（通常是-128到127，对于有符号字符；0到255，对于无符号字符）。

用途和语义：

- int 是为了存储一般大小的整数而设计的，适用于大多数整数运算和存储需求。
- char 主要用于存储字符数据（如ASCII码），但也可以用于存储小整数，特别是当你需要节省空间时

内存效率：

- 如果你知道你的整数数据将始终在一个很小的范围内（如0-255），并且内存使用是一个关键因素，那么使用 char（特别是无符号 unsigned char）可能是一个好选择。
- 然而，如果数据范围超出 char 的能力，使用 int 将是必要的。

`signed char` 的取值范围是从 -128 到 127，而 `unsigned char` 的取值范围是从 0 到 255。


## static_cast 和 reinterpret_cast 的区别

- `dynamic_cast`：dynamic_cast 用于在**多态类型之间**进行类型转换，它在运行时检查转换的有效性。

- `static_cast`: **编译时类型检查，编译时类型转换（所以是 static 的，编译时就进行转换）**。它只允许在存在明确的转换路径时进行转换，例如基类指针到派生类指针（向上转型安全，向下转型需要小心），数值类型之间的转换，以及用户自定义的转换运算符。 它更安全，因为编译器会尽力检查转换的有效性。

- `reinterpret_cast`: 执行低级别的**位模式**重新解释。它不进行任何类型检查，**直接将一个指针类型的位模式解释为另一个指针类型**。这非常危险，因为它可能导致程序崩溃或产生不可预测的结果，尤其是在涉及不同数据类型大小或对齐方式时。

- `const_cast`: **只有一个基本用法**：移除或添加 `const` 或 `volatile` 属性。



# c++17 结构化 binding   [语法糖]

简化了从复合类型中提取数据的操作。

~~~cpp
SmallVector<std::tuple<CostModelFn, std::string, double>> costModelList = {
        // threshold 0 mean using static shape if possible
        {dynamicBufferizationCost, "dynamicBufferizationCost", 0},
        {workloadBalancedCost, "workloadBalancedCost", 1},
        {vectorRegEfficiencyCost, "vectorRegEfficiencyCost ", -1},
        {computationIntensityOnL2Cache, "computationIntensityOnL2Cache",-1},
        {memoryConsumptionOnThreadCost, "memoryConsumptionOnThreadCost", -1},
        {paddingCost, "paddingCost", -1}};

for (auto &&[fn, name, threshold] : costModelList) {
    LLVM_DEBUG(llvm::dbgs() &lt;&lt; name &lt;&lt; "\n");
    configCandidates = filterConfigByCostModel(
        configCandidates, linalgOp, shape, sysDesc, fn, 0.5, threshold);
}
~~~

`auto &&[fn, name, threshold] : costModelList` 允许你在for循环中直接解构（destructure）或绑定（bind）到数据结构的元素。结构化绑定通常用于元组、对（pair）或具有公共非静态数据成员的聚合类型（如结构体或数组）。 这里的 auto && 表示使用通用引用（forwarding reference），它可以绑定到左值或右值。

`auto&&` 如何理解？它创建了一个所谓的通用引用（forwarding reference）。通用引用是一个类型推导上下文中的右值引用，它可以根据初始化表达式是左值还是右值来绑定到左值或右值。

- 左值：通常指的是一个持久的对象，它有一个明确的名称，可以在多个表达式中使用。例如，变量、数组元素和对象的成员都是左值。
- 右值：通常指的是一个临时的对象，它不会在当前表达式之外存在。例如，字面量和临时对象都是右值。

`auto&&` 非常适合用于模板编程和泛型编程，**因为它允许编写可以同时处理左值和右值的代码**。简单的例子，展示了 `auto&&` 如何根据赋值的类型来绑定到左值或右值：

~~~cpp
int x = 42; // x是左值
auto&& ref1 = x; // ref1是左值引用，类型是int&，即 ref1 引用的左值x
auto&& ref2 = 42; // ref2是右值引用，类型是int&&，即 ref2 引用了右值42
~~~


