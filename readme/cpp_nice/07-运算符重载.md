

实战代码见文件`overload.h`

参考了这里的理解：http://c.biancheng.net/view/2309.html

## 运算符重载

~~~cpp
Girl g3 = g1 + g2;  // 本质上见下
Girl g3 = g1.operator+(g2);

char i3 = i1 + i2;  // 本质上见下
char i3 = operator+(i1, i2); 
~~~

## 运算符重载要遵循的原则

1. 重载不能改变运算符的优先级和结合性
2. 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变
3. 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的。
4. 运算符重载函数既可以作为类的成员函数，也可以作为全局函数

将运算符重载函数作为**类的成员函数时**，二元运算符的参数只有一个，一元运算符不需要参数。之所以少一个参数，是因为这个参数是隐含的。例如，上节的 complex 类中重载了加法运算符：

`complex operator+(const complex& A) const;` 当执行： `c3 = c1 + c2;` 会被转换为： `c3 = c1.operator+(c2);` 通过 this 指针隐式的访问 c1 的成员变量。

运算符重载函数作为**全局函数时**，二元操作符就需要两个参数，一元操作符需要一个参数，**而且其中必须有一个参数是对象**，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质。
    
例如，下面这样是不对的：

~~~cpp
int operator+ (int a, int b){
    return (a - b);
}
~~~

`+` 号原来是对两个数相加，现在企图通过重载使它的作用改为两个数相减， 如果允许这样重载的话，那么表达式 4+3 的结果是 7 还是 1 呢？显然，这是绝对禁止的。

如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是 C++ 内置类型的数据，例如：

~~~cpp
complex operator+(int a, complex &c){
    return complex(a + c.real, c.imag);
}
~~~

它的作用是使一个整数和一个复数相加。

另外，将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为**友元函数**。原因很简单，该函数大部分情况下都需要使用类的 private 成员。

上节的最后一个例子中，我们在全局范围内重载了 + 号，并在 complex 类中将运算符重载函数声明为友元函数，因为该函数使用到了 complex 类的 m_real 和 m_imag 两个成员变量，它们都是 private 属性的，默认不能在类的外部访问。

6. 重载**强制类型转换运算符时**，不需要指定返回值类型，因为返回值类型是确定的，就是运算符本身代表的类型，在这里就是 double。

    ~~~cpp
    class Complex {
        double real, imag;
    public:
        Complex(double r = 0, double i = 0) :real(r), imag(i) {};
        operator double() { return real; }  //重载强制类型转换运算符 double
    };
    int main() {
        Complex c(1.2, 3.4);
        cout << (double)c << endl;  //输出 1.2
        double n = 2 + c;  // 等价于 double n = 2 + c.operator double()  ***
        cout << n;  //输出 3.2
    }
    ~~~

    `(double)c`等价于`c.operator double()`。有了对 double 运算符的重载，在本该出现 double 类型的变量或常量的地方，如果出现了一个 Complex 类型的对象，那么该对象的 operator double 成员函数就会被调用，然后取其返回值使用。
    
    比如这一行：`double n = 2 + c;`编译器认为本行中c这个位置如果出现的是 double 类型的数据，就能够解释得通，而 Complex 类正好重载了 double 运算符，等价于 `double n = 2 + c.operator double();`


## 1. 下标运算符重载  `overload_subscriptor.h`  [记住]

C++ 规定，下标运算符`[ ]`必须以成员函数的形式进行重载。该重载函数在类中的声明格式如下：

`返回值类型& operator[ ] (参数);`

和：

`const 返回值类型& operator[ ] (参数) const;`

使用第一种声明方式，[ ]不仅可以访问元素，还可以修改元素。使用第二种声明方式，[ ]只能访问而不能修改元素。**在实际开发中，我们应该同时提供以上两种形式**，这样做是为了适应 const 对象，因为通过 const 对象只能调用 const 成员函数，如果不提供第二种形式，那么将无法访问 const 对象的任何元素。***

~~~cpp
int& Array::operator[](int i) {  // 访问的对象可以被改
	return m_ptr[i];
}
const int& Array::operator[](int i) const {  // 访问对象不能被改
	return m_ptr[i];
}
...
Array arr(10); 
// arr[2] = 5; // 本质上是执行下
arr.operator[](2) = 5;  // 将5写入m_ptr[2]
~~~

返回值是&，所以该 operator 可以放在 = 左边。

## 2. 赋值运算符的重载 `overload_assignment.h`  [记住]

**初始化**和**赋值**的区别：在定义的同时进行赋值叫做初始化（Initialization），定义完成以后再赋值（不管在定义的时候有没有赋值）就叫做赋值（Assignment）。初始化只能有一次，赋值可以有多次。

即使我们没有显式的重载赋值运算符，编译器也会以**默认地方式重载它**。默认重载的赋值运算符功能很简单，**就是将原有对象的所有成员变量一一赋值给新对象**，这和默认拷贝构造函数的功能类似。

对于简单的类，默认的赋值运算符一般就够用了，我们也没有必要再显式地重载它。但是当类持有其它资源时，例如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认的赋值运算符就不能处理了，我们必须显式地重载它，这样才能将原有对象的所有数据都赋值给新对象。

以Array类为例，见文件`overload_assignment.h`

~~~cpp
Array& Array::operator=(const Array& arr) {
	if (this != &arr) { // 判断是否给自己赋值
		this->m_length = arr.m_length;
		free(this->m_ptr);
		this->m_ptr = (int*)calloc(this->m_length, sizeof(int));
		memcpy(this->m_ptr, arr.m_ptr, m_length * sizeof(int));
	}
	return *this;
}
~~~

上述代码

1. `operator=()` 的返回值类型为`Array&`，这样不但能够避免在返回数据时调用拷贝构造函数，还能够达到连续赋值的目的。下面的语句就是连续赋值： 
   ~~~cpp
   arr4 = arr3 = arr2 = arr1;
   ~~~
2. `if( this != &arr)` 语句的作用是「判断是否是给同一个对象赋值」：如果是，那就什么也不做；如果不是，那就将原有对象的所有成员变量一一赋值给新对象，并为新对象重新分配内存。
3. `return *this` 表示返回当前对象（新对象）。
4. `operator=()` 的形参类型为`const Array&`，这样不但能够避免在传参时调用拷贝构造函数，还能够同时接收 const 类型和非 const 类型的实参，这一点已经在《C++拷贝构造函数》中进行了详细讲解。
5.  赋值运算符重载函数除了能有对象引用这样的参数之外，也能有其它参数。但是其它参数必须给出默认值，例如：
    ~~~cpp
    Array & operator=(const Array &arr, int a = 100);
    ~~~
本质上，赋值运算符的行为由实际定义决定。
