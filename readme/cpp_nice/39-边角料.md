
知道什么是重点，什么是边角料，首抓重点内容，这里记录边角料。


## Linkage [链接时的可见性]

描述了名称（如变量、函数、类等）在多个**编译单元**（.cpp 文件）之间，一个声明的名称是否可见。

1. 内部链接性（Internal Linkage）：

当名称具有内部链接性时，它只在定义它的编译单元内可见。这意味着如果两个不同的源文件中都定义了具有相同名称的内部链接性变量或函数，它们实际上是完全独立的实体。

在C++中，可以通过在**匿名命名空间**中声明名称或使用**static**关键字修饰**的全局变量或函数**来给予名称内部链接性。具有内部链接性的名称在程序的其他部分是不可见的，这有助于避免名称冲突，并提供了一种封装实现细节的方式。

2. 外部链接性（External Linkage）：

声明的名称在所有编译单元中可见。前提是它们在其他编译单元中被**适当地声明**（通常是通过包含相应的**头文件**）。**外部链接性允许不同的编译单元共享和访问相同的变量或函数**。 在 C++ 默认情况下，**非const**的全局变量和函数具有外部链接性。

**`extern` 修饰的全局变量具有外部链接（external linkage）。 所有翻译单元都可以访问同一个变量。**  这是与函数的前向声明的区别。

3. 无链接性（No Linkage）：
**局部变量**（在函数内部声明的变量）具有无链接性，它们只在定义它们的特定作用域内可见。



## 存储期类型 [声明周期]

- 自动存储期（automatic storage duration）：它的生命周期仅限于函数调用的范围内。自动构造和析构+栈分配+无需手动管理+生命周期限制
- 静态存储期（static storage duration）
- 线程局部存储期（thread-local storage duration）
- 动态存储期（dynamic storage duration）

C++中的存储期类型（storage duration types）是为了提供**不同的内存管理策略**，以**满足不同场景下对变量生命周期和作用域的需求**。存储期类型决定了变量的分配时间、生存时间、以及何时被销毁。这些类型允许程序员根据具体的应用场景选择最合适的内存管理方式。以下是C++中几种存储期类型的原因和用途：

- 自动存储期（Automatic Storage Duration）：用于**函数内部的局部变量**，这些变量在函数调用时自动创建，在函数返回时自动销毁。这种类型的变量适用于**临时数据和函数内部**的计算。
- 静态存储期（Static Storage Duration）：用于**全局变量和静态局部变量**，这些变量在程序启动时分配，在程序结束时销毁。静态存储期的变量适用于需要**在程序的整个生命周期内保持状态**的情况。
- 线程局部存储期（Thread-Local Storage Duration）：用于**线程局部变量**，这些变量对每个线程都是唯一的，并在线程开始时创建，在线程结束时销毁。线程局部存储期的变量适用于**多线程程序中需要保持线程间独立**的数据。
- 动态存储期（Dynamic Storage Duration）：用于**动态分配的变量**（如使用`new`或`malloc`分配的内存），程序员需要显式地创建和销毁这些变量。动态存储期的**变量适用于生命周期不确定或大小不固定的数据结构**。



## handle 一般是什么 [抽象的概念，它代表了一个资源]

在 C++ 中，"handle" 是一个常用的术语，通常指的是一个引用或指针，用于引用或指向另一个对象或资源。这个术语并不是 C++ 语言的一部分，而是一种编程习惯或者说是一种设计模式。例如，文件句柄（file handle）是一个常见的例子。当你打开一个文件时，操作系统会返回一个文件句柄，你可以使用这个句柄来读取、写入或关闭这个文件。在这种情况下，**句柄是一个抽象的概念，它代表了一个资源**，你可以通过它来操作这个资源，但你并**不需要知道这个资源的具体实现细节**。

另一个例子是智能指针（smart pointer）。智能指针是一种对象，它像一个指针一样工作，但当你不再需要它指向的对象时，它会自动删除这个对象。在这种情况下，智能指针是一个句柄，它代表了一个对象，你可以通过它来操作这个对象，但你并不需要管理这个对象的生命周期。总的来说，"handle" 是一种设计模式，它允许你通过一个简单的接口来操作复杂的资源，而不需要知道这个资源的具体实现细节。

