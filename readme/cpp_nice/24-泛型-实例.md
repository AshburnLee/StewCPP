

# 递归模板函数    [拿来用]

~~~cpp
// Macro for boolean checks
#define VCONDCHECK( \
        logtype, logsubtype, component, condition, status, msg, ...) \
    do { \
        if (!(condition)) { \
            VINFO(logtype, logsubtype, component, msg, ##__VA_ARGS__); \
            return status; \
        } \
    } while (0)

#define VCHECK_MATMUL(cond, msg, ...) \
    VCONDCHECK(create, check, matmul, (cond), status::invalid_arguments, msg, \
            ##__VA_ARGS__);

template <typename T, typename P>
constexpr bool everyone_is(T val, P item) {
    return val == item;
}

template <typename T, typename P, typename... Args>
constexpr bool everyone_is(T val, P item, Args... item_others) {
    return val == item && everyone_is(val, item_others...);
}

VCHECK_MATMUL(everyone_is(ndims, src_md->ndims, weights_md->ndims),
        VERBOSE_INCONSISTENT_NDIMS, "src", "weights");
~~~

在编译阶段，递归模板函数 `everyone_is` 主要做了以下几个事情：

1. 实例化模板函数：编译器会根据函数调用的参数类型，实例化递归模板函数 `everyone_is` 的具体实现。对于每个不同的参数类型组合，编译器会生成一个对应的函数实例。
2. 展开递归调用：当递归模板函数 `everyone_is` 被调用时，编译器会根据参数的数量，展开递归调用。例如，如果有三个参数，编译器会展开为 `val == item && everyone_is(val, item_others...)`，其中 item_others 是剩余的参数。
3. 进行比较操作：在展开的递归调用中，编译器会对每个参数进行比较操作，即 `val == item`。**这些比较操作会在编译阶段进行求值，而不是在运行时**。***
4. 生成结果：根据比较操作的结果，编译器会生成一个布尔值作为函数的返回值。如果所有的比较操作都返回 true，则最终的结果为 true，否则为 false。
总的来说，递归模板函数在编译阶段通过实例化、展开递归调用和比较操作来生成最终的结果。这种方式使得函数的逻辑在编译时就能够确定，从而提高了代码的效率和性能。


另一个实例：

~~~cpp
// Base case
template <typename T, typename P>
constexpr bool one_of(T val, P item) {
    return val == item;
}
// Recursive step
template <typename T, typename P, typename... Args>
constexpr bool one_of(T val, P item, Args... item_others) {
    return val == item || one_of(val, item_others...);
}

one_of(RUNTIME_DIM_VAL, s_dim, w_dim, d_dim, b_dim)
~~~

该递归方式简洁地实现了检查val是否存在于**变长参数列表**中的功能。 **编译器**会在编译时展开递归，最终生成高效的代码，无需运行时循环。

另一个实例：

~~~cpp
template <typename T, typename P>
constexpr bool one_of(T val, P item) {
    return val == item;
}
template <typename T, typename P, typename... Args>
constexpr bool one_of(T val, P item, Args... item_others) {
    return val == item || one_of(val, item_others...);
}

template <typename... Args>
constexpr bool any_null(Args... ptrs) {
    return one_of(nullptr, ptrs...);
}

。。。
// 使用
if (utils::any_null(stream, compiled_partition, inputs, outputs)) {
    return status::invalid_arguments;
}
~~~
一般是工具函数，可以直接拿来用



## `template <typename T, template <typename> class Functor>` 表达是什么意思

- `typename T`: 这是一个**类型模板参数**。 它表示一个类型，在模板实例化时会被替换为具体的类型，例如 `int, float, std::string` 等。
- `template <typename> class Functor`: 这是一个**模板模板参数**。 它表示一个模板类，这个模板类本身又接受一个类型参数。 `Functor` 通常代表一个仿函数 (functor)，也就是一个重载了 `operator()` 的类或结构体，它可以像函数一样被调用。

这个声明定义了一个模板，它可以接受一个具体的类型 T 和一个具体的模板类 Functor 作为参数。 Functor 模板类必须接受一个类型参数，这个类型参数通常与 T 相关或相同。这种声明方式提供了强大的灵活性，允许你编写通用的模板代码，可以处理各种类型和不同的操作，而无需编写大量的重复代码。 

实例：

~~~cpp
// 定义一个简单的仿函数模板
template <typename T>
struct AddOne {
  T operator()(T x) const {
    return x + 1;
  }
};

// 定义另一个仿函数模板
template <typename T>
struct Square {
  T operator()(T x) const {
    return x * x;
  }
};

template <typename T, template <typename> class Functor>
T apply_functor(T value) {
  Functor<T> functor;
  return functor(value);
}

int main() {
  int x = 5;
  float y = 2.5f;

  // 使用 AddOne 仿函数
  int result1 = apply_functor<int, AddOne>(x); // result1 = 6
  float result2 = apply_functor<float, AddOne>(y); // result2 = 3.5f

  // 使用 Square 仿函数
  int result3 = apply_functor<int, Square>(x); // result3 = 25
  float result4 = apply_functor<float, Square>(y); // result4 = 6.25f

  return 0;
}
~~~


