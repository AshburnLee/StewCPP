
## 为什么将极其简单的函数 inline


## 函数调用栈

函数是一个可以重复使用的代码块，CPU 会一条一条地挨着执行其中的代码。CPU 在执行主调函数代码时如果遇到了被调函数，主调函数就会暂停，CPU 转而执行被调函数的代码；被调函数执行完毕后再返回到主调函数，主调函数根据刚才的状态继续往下执行。【**这就函数调用栈**】

一个 C/C++ 程序的执行过程可以认为是多个函数之间的相互调用过程，它们形成了一个或简单或复杂的调用链条，这个链条的**起点是 main()，终点也是 main()**。当 main() 调用完了所有的函数，它会返回一个值（例如 return 0;）来结束自己的生命，从而结束整个程序。

## 函数调用的开销

函数调用是有时间和空间开销的：

- 程序在执行一个函数之前需要做一些**准备工作**：要将实参、局部变量、返回地址以及**若干寄存器**都压入栈中，
- 然后才能执行函数体中的代码，
- 函数体中的代码执行完毕后还要**清理现场**：将之前压入栈中的数据都**出栈**，然后接着执行函数调用位置以后的代码。

所以：

- 如果函数体代码比较多，需要较长的执行时间，那么函数调用机制占用的时间可以忽略；
- 如果函数只有一两条语句，那么大部分的时间都会花费在函数调用机制上，这种时间开销就就不容忽视。

所以：

为了消除函数调用的时空开销，C++ 提供一种提高效率的方法，即在编译时将函数调用处用函数体替换，同时用实参代替形参，类似于 C 语言中的宏展开。

这种在函数调用处**直接**嵌入函数体的函数称为内联函数（Inline Function）.

当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU 时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。

## inline 缺点： 

使用内联函数又很明显的缺点，编译后的程序会存在**多份相同的函数拷贝**，如果**被声明为内联函数的函数体非常大，那么编译后的程序体积也将会变得很大**，所以再次强调，一般只将那些短小的、频繁调用的函数声明为内联函数。***

最后需要说明的是，对函数作 inline 声明只是程序员**对编译器提出的一个建议**，而不是强制性的，并非一经指定为 inline 编译器就必须这样做。编译器有自己的判断能力，它会根据具体情况决定是否这样做。

严格上讲，inline 函数不应该有函数声明，直接定义就好，这是好的编码规范，可避免一些麻烦：

在多文件编程中，我们将声明放在 header 中，将定义放在 src 中，鼓励这种将函数定义和函数声明分开的做法，但，不适用于 inline 函数：将 inline 函数的声明和定义分散到不同的文件中会出错，比如：

## inline 最佳实践

将inline函数的定义放在头文件中，以确保所有调用该函数的源文件都能访问到其定义。***

文件`utils.h`:

~~~cpp
#ifndef UTILS_H
#define UTILS_H
#include <iostream>

inline void Func() {
    std::cout << "inline function" << endl;
}

#endif
~~~

文件`utils.cpp`: 可以是空文件。
文件`main.cpp`：

~~~cpp
#include <iostream>
#include "utils.h"
using namespace std;

int main() {
    Func();
    return 0;
}
~~~


## 关键点

- 内联展开 (Inlining) 是一个编译器优化: inline 关键字只是一个建议，编译器可以自由地选择是否内联展开 inline 函数。 编译器会根据函数的大小、复杂度以及其他因素来决定是否进行内联。 如果编译器决定不进行内联，那么 inline 函数的行为就和普通函数完全一样，它会占用可执行文件的空间，并且可以被重复调用。

- 内联展开后的代码仍然存在于可执行文件中: 即使编译器进行了内联展开，展开后的代码仍然存在于可执行文件中。 它只是不再是一个独立的函数，而是**被复制到**调用它的函数中。 这可能会导致可执行文件体积增大，但代码仍然存在，并没有“没了”。

- inline 函数的代码可以被重复利用

- 内联展开后的代码仍然位于程序的**虚地址空间**中。

所以在多文件编程中，强烈建议**将 inline 函数直接放在 header 中**。
