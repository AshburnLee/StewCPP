
## 编译

`cmake -G "MinGW Makefiles" -DCMAKE_BUILD_TYPE=Debug ..`

`make` 

## 设置编译类型

`set(CMAKE_BUILD_TYPE Debug)`
`set(CMAKE_BUILD_TYPE Release)`

更好的是在 cmake 时制定类型

`cmake -B build -DCMAKE_BUILD_TYPE=Debug`

## 编译选项，编译优化

配置编译选项，`-Wall`表示显示所有 warning

`add_compile_options(-Wall -Wextra -pedantic -Werror)`

在 CMakeLists.txt 中，设置

debug 模式，指明不进行代码优化：
`set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -g -O0")`

release 模式，设置优化等级为O2：
`set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -O2")`

## 关于优化等级：

官方详细的解释：https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#Optimize-Options

大致上你应该知道：

1. gcc中指定优化级别的参数有：`-O0、-O1、-O2、-O3、-Og、-Os、-Ofast`。

2. 在编译时，如果没有指定上面的任何优化参数，则默认为 `-O0`，即没有优化。

3. 参数 `-O1、-O2、-O3` 中，**随着数字变大，代码的优化程度也越高**，不过这在某种意义上来说，也是以牺牲程序的可调试性为代价的。

4. 参数 `-Og` 是在 `-O1` 的基础上，去掉了那些影响调试的优化，所以**如果最终是为了调试程序**，可以使用这个参数。不过光有这个参数也是不行的，这个参数只是告诉编译器，编译后的代码不要影响调试，但调试信息的生成还是靠 `-g` 参数的。

5. 参数 `-Os` 是在 `-O2` 的基础上，去掉了那些会导致最终可执行程序增大的优化，**如果想要更小的可执行程序**，可选择这个参数。

6. 参数 `-Ofast` 是在 `-O3` 的基础上，添加了一些非常规优化，这些优化是通过打破一些国际标准（比如一些数学函数的实现标准）来实现的，所以一般不推荐使用该参数。

7. 如果想知道上面的优化参数具体做了哪些优化，可以使用 `gcc -Q --help=optimizers` 命令来查询，比如下面是查询 `-O3` 参数开启了哪些优化：

## 避免过度优化

`volatile` 关键字能够阻止编译器的过度优化

## 添加全局宏定义

在源码中通过宏实现相应的代码逻辑

`add_definitions(-DEBUG -DREAL_COOL_ENGINEER)`

## 添加include目录

通过命令来设置头文件的搜索目录：

`include_directories(src/c)`

## cmake

如何查看上一次的 cmake 编译选项？答：查看 build目录下的 `CMakeCache.txt` 文件即可，并且可以看到某些默认的选项其默认值是啥

## -fPIC

`g++ -shared -fPIC tmp.cpp -o libtmp.so` 这个编译选项的作用是于生成位置无关代码（`Position Independent Code`, `PIC`）。在 C++ 项目中，尤其是涉及到动态链接库（shared libraries）时，这个选项非常重要。

作用是提高代码的灵活性

1. 位置无关代码：使用 `-fPIC` 编译的代码可以在内存中的任何位置执行，而不需要依赖于特定的内存地址。这对于动态链接库非常重要，因为它们可能会被加载到内存中的不同位置。***
2. 共享库：当你编译一个共享库时，使用 `-fPIC` 可以确保库中的代码可以在不同的进程中共享，从而节省内存。***

在 CMake 项目中，你可以通过设置目标属性来使用 `-fPIC` 选项 `POSITION_INDEPENDENT_CODE`：
~~~sh
add_library(example SHARED example.cpp)
set_target_properties(example PROPERTIES POSITION_INDEPENDENT_CODE ON)
~~~


## cmake 构建结果中的 .o .so .a 文件分别为是什么？分别是通过cmake什么指令 得到的？

- `.o` 文件：这是一个目标文件（Object File），它是源代码文件（如 `.c` 或 `.cpp`）**经过编译但未链接**生成可执行文件或库文件的中间产物。在 CMake 中，目标文件通常是自动由 `add_executable` 或 `add_library` 命令生成的，不需要显式指令来创建单独的 `.o` 文件。所以 `.o` 只是最后连接过程的输入之一，还需要 提供其他的库文件。

    - 编译过程：编译过程是将源代码转换为机器代码（或接近机器代码的中间表示）的过程。在这个过程中，编译器会进行词法分析、语法分析、语义分析、优化等步骤，并将最终生成的代码放入 .o 文件中。这个过程是编译过程的一部分，**但还没有完成，因为 .o 文件中的代码可能还包含对其他文件（如库文件）中定义的函数或变量的引用**。
    - 链接过程：`.o` 文件是链接过程的输入之一。链接器（Linker）会收集所有必要的 `.o` 文件和**库文件**，解析它们之间的引用，并将它们合并成一个单一的可执行文件或库文件。这个过程中，链接器会处理如函数调用、变量访问等跨文件的引用。
    - 模块化：`.o` 文件的存在使得编译过程可以更加模块化。你可以单独编译项目中的每个源文件，生成对应的 `.o` 文件，然后在需要时再将它们链接起来。这有助于减少编译时间，因为当你修改了一个源文件时，只需要重新编译那个文件并重新链接，而不需要重新编译整个项目。

- `.so` 文件：这是一个共享对象文件（Shared Object File），在 Unix-like 系统中，它是动态链接库（Dynamic Link Library）的一种形式。在 CMake 中，你可以使用 `add_library` 命令并指定 `SHARED` 关键字来创建一个共享库：
`add_library(my_library SHARED source1.cpp source2.cpp)`

- `.a` 文件：这是一个静态库文件（Static Library File），它包含了一组目标文件，可以在链接时与其他目标文件一起生成最终的可执行文件。在 CMake 中，你可以使用 `add_library` 命令并指定 `STATIC` 关键字来创建一个静态库：
`add_library(my_library STATIC source1.cpp source2.cpp)`

如果没有指定 `SHARED` 或 `STATIC`，CMake 会根据全局变量 `BUILD_SHARED_LIBS` 的值来决定创建静态库还是动态库。如果 `BUILD_SHARED_LIBS` 被设置为 ON，则默认创建共享库；否则，默认创建静态库。

在构建过程中，CMake 会根据指定的目标和源文件，调用相应的编译器和链接器来生成这些文件。通常，你不需要直接操作 `.o` 文件，因为它们是构建过程的中间产物，而 `.so` 和 `.a` 文件则是最终的库文件，可以用于其他项目的链接或者作为应用程序的一部分。


## vscode 上找不到一个函数或变量的定义  [debug方法]

PATH_TO/TestCompiler/.vscode/c_cpp_properties.json

~~~yml
{
    "configurations": [
        {
            "name": "Linux",
            "includePath": [
                "${workspaceFolder}/**",
                "PATH_TO/llvm-project/llvm-install/include/**",
                "${workspaceFolder}/include/**",
                "${workspaceFolder}/../llvm-project/mlir/include/**",
                "PATH_TO/llvm-project/build/tools/mlir/include/mlir/IR/**",
                "PATH_TO/llvm-project/mlir/include/mlir/**"
            ],
            "defines": [],
            "compilerPath": "/usr/bin/clang",
            "cStandard": "c17",
            "cppStandard": "c++17",
            "intelliSenseMode": "linux-clang-x64"
        }
    ],
    "version": 4
}
~~~

通过 vscode terminal 中的 PROBLEM tab 尝试 fix，就会转到而配置文件了。
其中 `${workspaceFolder}` 是一个预定义的变量，它代表当前打开的工作区（workspace）的根目录的路径。

