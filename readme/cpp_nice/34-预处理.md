
# 预处理指令

预处理器指令不属于 C++ 语言本身，而是编译过程的一部分。包括条件编译、宏定义等、文件包含等。

## 源码中不能完成的控制，可以通过编译时的条件控制

~~~cpp
bool is_oil_backend() {
#if defined(ENABLE_OIL_BACKEND)
    return true;
#else
    return false;
#endif
~~~

## C++ 源代码中访问编译时指令

是的，在 C++ 源代码中，可以通过预处理器指令访问编译时的宏定义。

编译时指令是在编译器命令行中传给**编译器**的参数，使用 `-D` 表示定义的宏：`g++ -DMY_MACRO -o my_program my_program.cpp`. 这个命令在编译时定义了 MY_MACRO 宏. 那么在源代码中，你可以使用预处理器指令（如 `#ifdef MY_MACRO`）来检查这个宏是否已定义

C++ 中定义的宏是在源代码中使用 `#define` **预处理器**指令定义的: `#define MY_MACRO 1`，当预处理器运行时，它会替换所有 MY_MACRO 的实例为 1

## 条件编译指令什么时候区分代码  [答-预处理阶段区分代码]

~~~cpp
bool is_g_backend() {
#ifdef GOODS_BACKEND
    return true;
#else
    return false;
#endif
}
~~~

宏 `GOODS_BACKEND` 是在**编译时用来区分代码**的。预处理器指令 `#ifdef、#ifndef、#define、#else` 和 `#endif` 是**编译时指令**，它们在编译器开始编译代码之前就已经被处理了。

即如果在编译时定义了宏 `GOODS_BACKEND`（例如，通过编译器的命令行参数`-DGOODS_BACKEND`），那么 `is_g_backend()` 函数将返回 true。如果没有定义 `GOODS_BACKEND`，函数将返回 false。这意味着，决定 `is_g_backend()` 函数行为的是编译时的条件，而不是运行时。一旦程序被编译，`is_g_backend()` 的返回值就已经固定了，不会在程序运行时改变。


## 可变参数宏中，你应该学到什么？ [宏]

~~~cpp
#define ASSIGN_VALUES_TO_VAR(var, ...) \
    do { \
        auto val = 1 ? __VA_ARGS__ : var; \
        if (sizeof(#__VA_ARGS__) != sizeof("")) { \
            var = val; \
            std::cout << var << std::endl; \
        } else { \
            std::cout << var << std::endl; \
        } \
    } while(0)

float f = 0.0;
ASSIGN_VALUES_TO_VAR(f);
std::cout << f << std::endl;
ASSIGN_VALUES_TO_VAR(f, 4.5);
std::cout << f << std::endl;
~~~

通过一个三元运算符（`int a = 1 ? : 2`是 C++ 的 GNU 扩展， 不是标准C++， 标准c++中三元运算符不能有空表达式）

1. 宏只是替换，不会进行执行，分支都会被替换，所以你在条件分支中将 `__VA_ARGS__` 的存在做判断，但这个可变参数没有给出时，这个参数的读写**就变成了对一个空进行读写**。所以报错：`error: expected primary-expression before ‘;’ token`, 就是分号前应该有内容，却是空。
2. 宏有它的应用场景，不适用的场景不要用。（任何东西都是这样的） ***


## 局部带参宏定义，（去冗余简化代码） [简化代码]

~~~cpp
...
#define MD(name) my_query_##name##_md
    std::vector<my_query_t> query_fwd_in_mds {MD(src), MD(weights)};
    std::vector<my_query_t> query_fwd_out_mds {MD(dst), MD(workspace)};

    std::vector<my_query_t> query_bwd_in_mds {
            MD(src), MD(weights), MD(dst), MD(diff_dst), MD(workspace)};
    std::vector<my_query_t> query_bwd_out_mds {
            MD(diff_src), MD(diff_weights)};
#undef MD
...
~~~

作用，代码不会冗长，更能突出关键字。


## 可变参数宏，应用场景，给出一个例子

~~~cpp
// C++中可变参数宏可以用于简化代码，特别是在需要重复执行某个操作时。一个常见的应用场景是打印调试信息。
// 下面是一个例子：

#include <iostream>
#define DEBUG_PRINT(...) std::cout << "DEBUG: " << __VA_ARGS__ << std::endl;

int main() {
    int x = 42;
    DEBUG_PRINT("The value of x is " << x); // prints "DEBUG: The value of x is 42"
    return 0;
}
~~~

## 所以通过宏定义一个print 和 定义一个print函数，这两种方式的优劣？

- 宏定义优性能优势：它在预处理时判断并展开，没有函数调用开销；可在release 版本中消除相关代码。但是，宏不进行类型检查；宏是简单的文本替换，调试时难以定位问题；如果宏定义不当，导致代码混乱难以理解。

- 函数的优势：进行类型检查；调试更容易；代码可读性和可维护性更好。缺点是函数调用优开销。
