===

## 寻址

- 字节 (Byte): 是计算机存储数据的**最小可寻址单元**，通常由 8 个比特 (bit) 组成。 一个比特表示一个二进制位 (0 或 1)。

- 内存地址 (Memory Address): 是一个唯一的数字，用于标识内存中的**一个字节**。每一个字节都有唯一的地址。 内存地址通常以十六进制 (例如 0x1000、0x2000) 或十进制表示。

- 寻址 (Addressing): **是指 CPU 通过内存地址来访问内存中特定字节的过程**。 当 CPU 需要读取或写入数据时，它会向**内存控制器**发送内存地址，内存控制器则根据地址找到相应的字节，并进行数据传输。


## 内存布局

学习 C 语言是了解内存布局最简单、最直接、最有效的途径。c 比其他任何语言都贴近内存

- **虚拟内存**：假如计算机的内存容量为 2G，运行着10个程序，共占用 3G 空间，显然是不够的。OS 帮我们解决了。上述情况下，OS 会将在那时不用的数据写回硬盘；需要时再从硬盘中加载，同时将另一部分不用的数据写回硬盘。这样，硬盘中会有一部分空间存放内存中暂时不用的数据，这部分空间称作**虚拟内存**。 

- **交换空间**（swap space）： 是**硬盘上专门分配**的一块区域，用作虚拟内存的一部分。 虚拟内存是一个更广泛的概念，而交换空间只是实现虚拟内存的一种机制。 即使没有交换空间，操作系统仍然可以使用其他技术来实现虚拟内存

- **寄存器**：cpu 中很小、很快的存储部件，容量很小。对于 32 位 cpu，每个寄存器可以存 32 位数据，对于 64 位 cpu，可存 64 位数据。一般说的 cpu 的位数，就是寄存器的位数。

CPU 则根据编译器生成的机器码，将这些高级语言的**内存访问操作**转换为**对地址总线**的操作。

计算机内存是以字节位单位划分的，理论上 cpu 可以访问任意编号的字节，但实际并非如此：

cpu 通过**地址总线来访问内存**，一次需要处理多少个字节的数据，就会命令地址总线读几个字节的数据。如，32位 cpu 一次可以处理 4 字节的数据，那么每次从内存读取4个字节数据；少了浪费主频（主频越高，寻址越快），多了读不了。

32位 cpu 实际**寻址步长**是4字节，即，**只对标号为4的倍数的内存寻址**，即 0、4、8、12、1000：

~~~bash
|0 |1 |2 |3 |4 |5 |6 |7 |8 |...|1000|1001|1002|1003|
\____  ____/ \____  ____/       \________  _______/
     \/          \/                      \/
  一次寻址    一次寻址                 一次寻址
~~~

这样做的寻址速度最快，不遗漏一个字节，也不重复寻址。

所以，在程序中，一个变量最好是在一个寻址步长范围内，这样读一次就可以读取到完整的变量，如果跨步长存储，就要读多次，后拼接数据，效率显然低了。

所以，将一个数据尽量放在步长之内，避免跨步长存储，这成为**内存对齐**，

为了提高效率，编译器会自动进行内存对齐：

~~~cpp
struct {
    int a;
    int b;
    char c;
} t = {10, 20, 'x'};
~~~

不考虑内存对齐，对象 t 占 4 + 4 + 1 = 9 个字节，但是为了内存对齐，c 实际占4字节，额外的3个会进行内存填充padding，将其浪费掉。编译器用空间换时间。

除了结构体，变量也会进行内存对齐：

~~~cpp
#include <stdio.h>
#include <stdlib.h>

int a;
char b;
int c;

int main() {
    // int a;
    // int b;
    // char c;
    printf("&a: %X\n&b: %X\n&c: %X\n", &a, &b, &c);
}
~~~
执行得到：

&a: 419034
&b: 419038
&c: 41903C

可见地址都是 4 的整数倍，并且是连着的。

但是，不同的编译器、对于局部和全局变量、 release 和 debug 下，内存对不对齐是不一定的。比如，当变量为局部变量时，MinGW 编译后，没有内存对齐。

虽然内存对齐和硬件有关，的但是决定对齐的方式是编译器，如果我的硬件是64位的，却以32位编译，那么还是会按照4个字节对齐。

其他语言，python、Java也会有内存对齐的问题。


## alignas(n)

`alignas(n)` 是 C++ 中的一个关键字，用于指定变量或数据类型的内存对齐方式。它确保变量或对象的**起始地址**是 n 的倍数。n 必须是 2 的幂，例如 1、2、4、8、16、32 等。

使用方法: `alignas(n)` 可以用在变量声明或结构体、类、联合体定义的前面：

~~~cpp
alignas(16) int x; // x 的地址将是 16 的倍数  这句话什么意思？
/*
计算机内存以字节为单位进行寻址。每个字节都有一个唯一的地址。 对齐是指数据在内存中的起始地址与数据大小之间的关系。 
例如，一个 int 类型变量通常占用 4 个字节。如果 int 变量的对齐方式是 4，则其地址必须是 4 的倍数（0, 4, 8, 12, 16, 20...）。
alignas(16) 强制 int 变量 x 的地址必须是 16 的倍数，即使 int 本身只需要 4 个字节。
*/

struct alignas(8) MyStruct {
  int a;
  double b;
};

alignas(32) MyStruct myVar; // myVar 的地址将是 32 的倍数
~~~

编译器可以进行自动的内存对齐。**在某些特定硬件架构或应用场景下，显式指定对齐方式可以提高性能**。 某些硬件平台（特别是那些具有缓存行和 SIMD 指令的平台）对**数据对齐**有特殊要求。如果数据未对齐，访问速度会显著降低。 **手动指定 alignas 可以确保数据对齐，从而提高访问速度。例如，在处理 SIMD 向量时，对齐可以避免跨缓存行加载数据，从而提高性能。**

注意：过度使用 alignas 可能**导致内存浪费，因为对齐会引入填充字节。 只有在性能至关重要的情况下才应该使用 alignas**。 仔细权衡性能提升和内存消耗。


## 每一个字节都有一个唯一的地址  ***

一个 float 类型的对象占用 4 个字节。 这 4 个字节在内存中是相邻的，并且每个字节都有自己的唯一地址。**当我们说一个 float 对象的地址时，通常指的是起始地址**。


## malloc 函数是如何实现的？实现自己的 malloc 函数

malloc 函数是 C++ 中用于动态分配内存的函数。它的实现通常依赖于操作系统提供的底层内存分配函数，如 brk 或 mmap 。具体实现方式因操作系统而异，但通常都是通过向操作系统**请求一定大小的内存块，并返回该内存块的首地址**来实现的。我只是请求，并没有填入数值，即这段内存块我预定了。

~~~cpp
#include <cstddef>
#include <cstdint>
#include <iostream>

#define MAX_MEM_SIZE 1024 // 内存池大小
#define ALIGNMENT 8 // 内存对齐大小

char mem_pool[MAX_MEM_SIZE]; // 内存池

// 对齐函数
size_t align(size_t size) {
    return (size % ALIGNMENT == 0) ? size : (size + (ALIGNMENT - (size % ALIGNMENT)));
}

void* my_malloc(size_t size) {
    static size_t offset = 0; // 当前内存池中已分配的内存大小，【offset是局部内的静态变量】
    size = align(size); // 对齐请求的内存大小
    if (offset + size > MAX_MEM_SIZE) { // 内存池已满，无法分配
        return nullptr;
    }
    void* ptr = mem_pool + offset; // 通过从mem_pool偏移offset来 标记一段空闲内存
    offset += size; // 更新已分配内存大小，以便下次分配时 空闲内存地址可以放文到。
    return ptr; // 返回内存块首地址
}

// 测试函数
int main() {
    char* ptr1 = static_cast<char*>(my_malloc(10));
    if (ptr1) {
        std::cout << "Allocated 10 bytes at " << static_cast<void*>(ptr1) << std::endl;
    } else {
        std::cout << "Failed to allocate 10 bytes" << std::endl;
    }

    double* ptr2 = static_cast<double*>(my_malloc(20 * sizeof(double)));
    if (ptr2) {
        std::cout << "Allocated " << 20 * sizeof(double) << " bytes at " << static_cast<void*>(ptr2) << std::endl;
    } else {
        std::cout << "Failed to allocate " << 20 * sizeof(double) << " bytes" << std::endl;
    }

    int* ptr3 = static_cast<int*>(my_malloc(1000 * sizeof(int)));
    if (ptr3) {
        std::cout << "Allocated " << 1000 * sizeof(int) << " bytes at " << static_cast<void*>(ptr3) << std::endl;
    } else {
        std::cout << "Failed to allocate " << 1000 * sizeof(int) << " bytes" << std::endl;
    }

    return 0;
}
~~~

注意：数组名会隐式地转换为指向其第一个元素的指针。*** `char pool[SIZE];` 是一个数组，`pool[0]` 等价于 `*(pool + 0)`。

## 泛型指针和泛型函数

上述函数 `void* my_malloc(size_t)` 就是一个泛型函数。

## 对齐函数 

确定 ALIGNMENT 大小：32位系统通常以4字节对齐，而64位系统则以8字节对齐。

~~~cpp
#define ALIGNMENT 8 // 内存对齐大小
size_t align(size_t size) {
    // 将 size 增加到下一个对齐边界的临界值 & 掩码
    return (size + (ALIGNMENT - 1)) & ~(ALIGNMENT - 1);
}

// 这个好理解，根据下面的结果马上写出这个逻辑
size_t align(size_t size) {
    return (size % ALIGNMENT == 0) ? size : (size + (ALIGNMENT - (size % ALIGNMENT)));
}

for (size_t i = 0; i <= 20; ++i) {
    std::cout << "align(" << i << ") = " << align(i) << std::endl;
}
~~~

这个函数作用是**将给定的 size 调整为一个对齐到指定字节边界的大小**。某些硬件要求数据必须对齐到 4 字节或 8 字节。对齐可以提高内存访存效率，因为**没有对齐的数据需要额外的内存访问操作**。

调整结果：
~~~sh
align(0) = 0
align(1) = 8 # 将1字节调整为8字节
align(2) = 8
align(3) = 8
align(4) = 8
align(5) = 8
align(6) = 8
align(7) = 8
align(8) = 8
align(9) = 16 # 将9字节调整为16字节
align(10) = 16
align(11) = 16
align(12) = 16
align(13) = 16
align(14) = 16
align(15) = 16
align(16) = 16
align(17) = 24
align(18) = 24
align(19) = 24
align(20) = 24
~~~