## C语言中没有函数重载

希望交换两个变量的值，这两个变量有多种类型，可以是 int、float、char、bool 等，我们需要通过参数把变量的地址传入函数内部。在**C语言**中，程序员往往需要分别设计出三个不同名的函数，其函数原型与下面类似：

~~~cpp
void swap1(int *a, int *b);      //交换 int 变量的值
void swap2(float *a, float *b);  //交换 float 变量的值
void swap3(char *a, char *b);    //交换 char 变量的值
void swap4(bool *a, bool *b);    //交换 bool 变量的值
~~~

但在**C++中**，这个很冗余。

C++ 允许多个函数拥有相同的名字，只要它们的参数列表不同就可以，这就是函数的重载（Function Overloading）。借助重载，一个函数名可以有多种用途。

参数列表又叫**参数签名**，包括参数的类型、参数的个数和参数的顺序，只要有一个不同就叫做参数列表不同。

注意，参数列表不同包括几种情况：参数的个数不同、类型不同或顺序不同，仅仅参数名称不同是不可以的。**函数返回值**也不能作为重载的依据。

在使用重载函数时，同名函数的功能应当相同或相近，不要用同一函数名去实现完全不相干的功能，虽然程序也能运行，但可读性不好。

函数的重载的规则：

- 函数名称必须相同。 
- 参数列表必须不同（个数不同、类型不同、参数排列顺序不同等）。
- 函数的返回类型可以相同也可以不相同。
- 同名函数的功能要相同或相近


## C++ 何做到函数重载

C++代码在**编译时**会根据参数列表对函数进行**重命名 name mangling**：

例如 `void Swap(int a, int b)` 会被重命名为类似 `_Swap_int_int`，`void Swap(float x, float y)` 会被重命名为`_Swap_float_float`。当发生函数调用时，编译器会根据传入的实参去逐个匹配，以选择对应的函数，如果匹配失败，编译器就会报错，这叫做**重载决议**（Overload Resolution）。

不同的编译器有不同的重命名方式，这里仅仅举例说明，实际情况可能并非如此。

从这个角度讲，函数重载仅仅是语法层面的，本质上它们还是不同的函数，占用不同的内存，入口地址也不一样。

