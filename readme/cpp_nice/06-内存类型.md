
## C++ 程序会用到的内存类型

一个 cpp 程序会使用到的内存类型有：

1. 静态存储区 (Static Storage Duration)：用来保存局部`static`变量，类中`static`变量，任何函数外的全局变量。

2. BSS （Block Started by Symbol）段 (BSS Segment):

    作用: 存储**未初始化**的全局变量和静态变量。
    特点: 与静态存储区紧密相关，内存分配在编译时完成，程序启动时初始化为 0。使用 BSS 可以减少可执行文件的大小。

3. 数据段 (Data Segment):

    作用: 存储**已初始化**的全局变量和静态变量。
    特点: 与静态存储区紧密相关，内存分配在**编译时完成**。

4. 代码段 (Code Segment/Text Segment):

    作用: 存储程序的可执行代码。
    特点: 内存分配在编译时完成，通常是只读的，以防止程序意外修改自身代码。

5. 常量存储区 (Constant Storage):

    作用: 存储程序中使用的常量，例如字符串字面量。
    特点: 内存分配在编译时完成，通常是只读的。

6. 栈内存（stack）：保存定义在函数内的 `非 static` 变量。保存函数调用信息。
7. 动态内存（heap）：存储动态分配的对象。但是使用完后，调用者必须显式地将空间释放。通常使用`new`和`delete`关键字。

动态内存使用时，`new` 在动态内存中分配空间并且返回一个指向该空间的指针（两件事）。`delete` 时，接受一个动态对象的指针，销毁该指针所指向的对象，并释放空间。

但是在正确的时间释放空间有时是很困难的，为了可以安全的使用动态内存，标准库提供了智能指针：`shared_ptr`和`unique_ptr`。

多个`shared_ptr`能共享一个对象；而一个`unique_ptr`只能独享一个对象。


## stack vs heap

栈（Stack）：

栈是一种内存区域，用于存储**局部变量**、**函数调用信息**等。
栈上的**内存管理是自动的**，由编译器在函数调用时自动分配和释放。
栈的大小通常有限，且分配和释放速度较快。

堆（Heap）：

堆是另一块内存区域，用于动态分配内存。
堆上的内存管理是**手动**或通过**智能指针**等工具进行的，需要显式地分配和释放。
堆的大小通常比栈大得多，但分配和释放速度较慢。

KAQ：如果我在一个函数里的 heap 中开辟了空间 `int* heapVar = new int(10)`; 但是并没有在这个函数结束时执行`delete heapVar;` 那么这块 heap 还会存在吗？在已在这个函数之外访问它吗？

答：这块内存将继续存在，即使函数已经返回。这种情况通常被称为**内存泄漏**，因为分配的内存没有被回收，而且如果你失去了指向该内存的指针，你将无法再访问或释放它。但即使函数结束后，你仍然可以访问在堆上分配的内存，前提是你有一个指向该内存的有效指针。比如你将这个指针返回给调用者或者存储在一个更高作用域的变量中。合理

~~~cpp
void myFunction() {
  int* heapVar = new int(10); // 分配内存

  // 使用 heapVar ...

  delete heapVar; // 释放内存  非常重要！ 如果没有这一行，分配的内存将无法被释放，导致内存泄漏。
  heapVar = nullptr; // 将指针设置为 nullptr，防止悬空指针
}
~~~

`delete heapVar` 虽然指针本身会在作用域结束时销毁，但设置 nullptr 是一个重要的**防御性编程措施**，可以提高代码的可靠性和可维护性.

最佳实践是 使用只能指针，即 RAII：

~~~cpp
...
std::unique_ptr<int> heapVar(new int(10)); // 使用 unique_ptr 管理内存
...
~~~


## 函数调用通常发生在栈上

过程:

- 函数调用前: 调用函数会将函数参数压入栈中。
- 函数调用: 程序跳转到被调用函数的起始地址。
- 栈帧创建: 被调用函数会为自身创建一个栈帧（stack frame），分配空间用于存储局部变量等。
- 函数执行: 被调用函数执行其代码。
- 栈帧销毁: 被调用函数执行完毕后，会销毁其栈帧，释放栈空间。 局部变量等数据会被清除。
- 返回: 程序从栈中取出返回地址，跳转到调用函数的下一条指令继续执行。

## 代码中， myptr 指向的是哪里的地址

~~~cpp
char* init() {
    char strs[] = "Hi, there"; // strs是一个局部变量，存储在stack上
    char* ptr = strs; // ptr指向strs的地址，也就是stack上的地址
    return ptr; // 返回ptr，也就是stack上的地址
}
int main() {
    char* myptr = init(); // myptr 指向的是 stack 上的地址
    do_somthing_with(myptr);
}
~~~

