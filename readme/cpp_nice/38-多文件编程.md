
1. 分模块编译，每个模块来自一个编译单元。
2. 声明与定义分离，
3. extern 告诉编译器，声明在其他地方

===

## 4阶段

预处理、编译、汇编、链接

例子：

当前项目中有 1 个 `student.h` 头文件，`student.cpp` 和 `main.cpp` 2 个源文件。接下来就用 g++ 命令执行此项目，其过程依次是：

1. **预处理**阶段，执行如下命令：

    ~~~sh
    [root@bogon ~]# g++ -E main.cpp -o main.i
    [root@bogon ~]# g++ -E student.cpp -o student.i
    ~~~

    其中，`-E` 选项用于限定 g++ 编译器**只进行预处理**而不进行后续的 3 个阶段；`-o` 选项用于指定生成文件的名称。Linux 系统中，通常用 ".i" 作为 C++ 程序预处理后所得文件的后缀名。


2. **编译**阶段，即对预处理阶段得到的 `-i` 文件做进一步的语法分析，生成相应的汇编代码文件。继续执行如下命令：

    ~~~sh
    [root@bogon ~]# g++ -S main.i -o main.s
    [root@bogon ~]# g++ -S student.i -o student.s
    ~~~

    其中，`-S` 选项用于限定 g++ 编译器对指定文件**进行编译**，得到的汇编代码文件通常以“.s”作为后缀名。感兴趣的读者可以使用 cat 命令查看生成文件的内容。

3. **汇编**阶段，即将汇编代码文件转换成可以执行的机器指令。继续执行如下命令：

    ~~~sh
    [root@bogon ~]# g++ -c main.s -o main.o
    [root@bogon ~]# g++ -c student.s -o student.o
    ~~~

    `-c` 指令用于限定 g++ 编译器**只进行汇编**操作，最终生成的目标文件（本质就是二进制文件，ELF文件，但还无法执行）通常以“.o”作为后缀名。目标文件中有了原函数对应的符号表了。

4. **链接**阶段，即将所有的目标文件(链接器的目标都是符号)组织成一个可以执行的二进制文件。执行如下命令：

    ~~~sh
    [root@bogon ~]# g++ main.o student.o -o student.exe
    ~~~

## 声明与定义

C++ 的编译过程通常是**分模块编译的**。每个 .cpp 文件会被独立编译成一个目标文件（.o 或 .obj）。

同属一个 C++ 项目中的所有代码文件是分别进行编译的（称为分离编译 separate compilation），只需要在编译成目标文件后再与其它目标文件做一次链接即可。例如，在 `a.cpp` 源文件中定义有一个 全局函数 `a()`，而在文件 `b.cpp`中需要调用这个函数。即便如此，处于编译阶段的 `a.cpp` 和 `b.cpp` 并**不需要知道对方的存在，它们各自是独立编译的**，只要最后将编译得到的目标文件进行链接，整个程序就可以运行。

那么，整个过程是如何实现的呢？从写程序的角度来理解，当文件 `b.cpp` 中需要调用 `a()` 函数时，**只需要先声明**一下该函数即可。这是因为，编译器在编译 `b.cpp` 时会生成一个**符号表**，类似 `a()` 这样**看不到定义的符号就会被存放在这个表中**。在链接阶段，**编译器就会在别的目标文件中去寻找这个符号的定义，一旦找到了，程序也就可以 顺利地生成了**（反之则出现链接错误）。 ***

注意，这里提到了两个概念，即“声明”和“定义”。所谓定义，指的是就是将某个符号完整的描述清楚，它是变量还是函数，变量类型以及变量值是多少，函数的参数有哪些以及返回值是什么等等；而“声明”的作用**仅是告诉编译器该符号的存在**，至于该符号的具体的含义，**只有等链接的**时候才能知道。***

基于声明和定义的不同，才有了 C++ 多文件编程的出现。试想如果有一个很常用的函数 f()，其会被程序中的很多 .cpp 文件调用，那么我们只需要在一个文件中定义此函数，然后在需要调用的这些文件中声明这个函数就可以了。

## 多文件编程注意

在 C++ 多文件编程中，如果 `.h` 头文件中只包含声明语句的话，即便被同一个 `.cpp` 文件引入多次也没有问题，因为**声明语句是可以重复的，且重复次数不受限制。**

`.h` 头文件的作用就是被其它的 `.cpp` 包含进去，其本身并不参与编译 (编译4步骤中没有操作 `.h` 文件)，但实际上它们的内容会在多个 `.cpp` 文件中得到编译。

通过 “ 符号的定义只能有一次 ” 的规则，我们可以很容易地得出，**.h文件中应该只放变量和函数的声明，而不能放它们的定义，这是 C++ 编程中的一条重要准则**。因为一个头文件的内容实际上是会被引入到多个不同的 .cpp 文件中的，并且它们都会被编译。换句话说，如果在头文件中放了定义，就等同于在多个 .cpp 文件中出现对同一个符号（变量或函数）的定义，纵然这些定义的内容相同，编译器也不认可这种做法（报**重定义错误**）。 ***

但是，比如当前这个 repo ，某个头文件确定只是被一个 source 文件 include，那么这个头文件就可以放定义，就无所谓了，总之不能有重复定义。

`.h` 头文件中只能存放变量或者函数的声明，而不要放定义。*** 例如：

~~~cpp
extern int a;
void f();
~~~

这些都是声明。反之：

~~~cpp
int a;
void f() {}
~~~

这些都是定义

## header or source file

- inline 函数可放在 h: inline 函数是一个例外。inline 函数的定义可以放在头文件中。编译器会尝试将 inline 函数的代码直接插入到调用它的位置，从而避免函数调用的开销。这不会导致“重定义”错误，因为每个 .cpp 文件中生成的代码都是独立的。

- constexpr 变量和函数可放在 h: constexpr 变量和函数，如果其值在编译时可以确定，也可以在头文件中定义。编译器会在编译时计算其值，并将其直接嵌入到代码中，避免运行时计算。

- static 变量和函数可放在 h: static 变量和函数的定义可以放在头文件中，但它们的**作用域**仅限于定义它们的**翻译单元**（.cpp 文件）。这意味着即使多个 .cpp 文件包含了相同的头文件，它们各自拥有的 static 变量或函数都是独立的，不会发生冲突。

- 模板：其定义通常也需要放在头文件中，因为模板代码在编译时会被实例化。如果模板定义放在 .cpp 文件中，编译器在编译其他 .cpp 文件时无法找到相应的模板实例化代码。 如何理解：当模板定义放在头文件中时，main.cpp 可以通过 #include "template.h" 将模板定义包含进来。这样，编译器在编译 main.cpp 时，**就能够看到模板的完整定义**，并且可以根据 main.cpp 中对模板的使用情况进行就地实例化。具体函数会在 main.cpp 编译生成的目标文件中被实例化出来，**链接器自然就能找到它了**。

- 类成员函数: 类成员函数的定义，除非显式声明为 inline，通常应该放在 .cpp 文件中，而其声明放在头文件中。

总结：为了避免“重定义”错误，头文件通常只包含变量和函数的声明，以及 inline 函数、constexpr 变量和函数、static 变量和函数、模板的定义。 其他类型的定义应该放在 .cpp 文件中。 理解这些例外情况对于编写正确的 C++ 代码至关重要。

## extern 用法是就是声明变量或函数，告诉编译器，该变量或函数在其他文件中定义了，链接时在其他文件中寻找定义。

extern 关键字用于**声明**一个变量或函数是在其他文件中定义的，告诉编译器在链接时在其他文件中寻找定义。

- 变量声明：在一个文件中定义一个变量，并在另一个文件中使用该变量时，需要在使用该变量的文件中进行声明。声明变量时，可以使**用 extern 关键字来告诉编译器该变量是在其他文件**中定义的：

~~~cpp
// a.c
int x = 10;

// b.c
extern int x;  // 声明变量x,告诉它，x已经在某处定义了，链接时会在其他文件中寻找x的定义
int main() {
    printf("%d\n", x); // 输出10
    return 0;
}
~~~

- 函数声明：在一个文件中定义一个函数，并在另一个文件中使用该函数时，需要在使用该函数的文件中进行声明。声明函数时，可以使用 extern 关键字来告诉编译器该函数是在其他文件中定义的：

~~~cpp
// a.c
void foo() {
    printf("Hello from foo!\n");
}

// b.c
extern void foo();
int main() {
    foo(); // 调用函数foo
    return 0;
}
~~~
