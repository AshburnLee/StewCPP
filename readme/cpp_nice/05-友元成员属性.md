
友元破坏了封装性，但是什么情况下使用友元类？

1. 紧密耦合的类。当两个类之间存在非常紧密的联系，需要频繁地访问彼此的内部状态时，可以考虑使用友元类。
2. 辅助类或助手类。当一个类主要用于辅助另一个类完成特定任务，并且需要访问其内部状态时，可以将辅助类声明为友元类。这可以避免在原始类中暴露过多的公共接口。***

## 友元成员函数

~~~cpp
class Point {
private:
    double x, y;

public:
    Point(double x, double y) : x(x), y(y) {}

    friend class Line; // 声明 Line 类为 Point 类的友元
};

class Line {
private:
    Point p1, p2;

public:
    Line(Point p1, Point p2) : p1(p1), p2(p2) {}

    double getLength() {
        // 因为 Line 是 Point 的友元，所以可以直接访问 Point 的私有成员
        return std::sqrt(std::pow(p2.x - p1.x, 2) + std::pow(p2.y - p1.y, 2));
    }
};

int main() {
    Point p1(1, 2);
    Point p2(4, 6);
    Line line(p1, p2);
    std::cout << "Line length: " << line.getLength() << std::endl;
    return 0;
}
~~~

Line 类需要计算两点之间的距离，这需要访问 Point 类的私有成员 x 和 y。为了避免创建公共的 getter 方法，Line 类被声明为 Point 类的友元。

为了避免使用友元，可以修改 Point 类，提供公共 getter 方法来访问 Point 的 x 和 y. 保持了封装性，并且代码的可读性和可维护性更好。 这通常是比使用友元更推荐的做法。*** 只有在性能至关重要，并且公共方法会带来显著的性能开销时，才考虑使用友元。

## 友元类、友元函数   [非实体，只是用来控制访问权限]

- 友元类的声明**位置不影响其访问权限**。无论声明在何处，友元类都可以访问该类的**所有成员**（包括私有和保护成员）。

- 友元的声明本质上**是编译时的概念**，用于控制访问权限，而**非一个运行时的实体**。所以友元的声明**不会直接反映在编译时的符号表中**。 当编译器遇到 `friend class` 声明时，它会记录这种友元关系。编译器会将友元类的信息**存储在类的元数据metadata**中，以便在后续的编译过程中使用。友元是访问控制规则，不是某个实体。

假设我们有两个类 MyClass 和 FriendClass，分别定义在 MyClass.h 和 FriendClass.h 文件中。我们想将 FriendClass 定义为 MyClass 的友元类。

~~~cpp
// MyClass.h 文件中的代码：

#ifndef MYCLASS_H
#define MYCLASS_H

class FriendClass; // 前向声明 FriendClass 类

class MyClass {
    friend class FriendClass; // 声明 FriendClass 类为友元类
private:
    int private_member; // MyClass 的私有成员
};

#endif // MYCLASS_H


// FriendClass.h 文件中的代码：

#ifndef FRIENDCLASS_H
#define FRIENDCLASS_H

#include "MyClass.h" // 包含 MyClass.h 头文件

class FriendClass {
public:
    void use_private_member(MyClass& obj) {
        int x = obj.private_member; // 通过 FriendClass 使用 MyClass 的私有成员
    }
};

#endif // FRIENDCLASS_H
~~~
