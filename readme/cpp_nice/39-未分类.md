
## __func__

`__func__`在每个函数体内部**由编译器自动定义**为一个静态的、值为当前函数名称的 `const char[]` 数组。

~~~cpp
void example() {
    std::cout << "Function name: " << __func__ << std::endl;
}

int main() {
    example();
    return 0;
}
~~~

## stdout 的缓冲机制

问题：

~~~cpp
printf("%s", s.c_str());
fflush(stdout);
~~~

和

~~~cpp
printf("%s", s.c_str());
~~~

前者输出到屏幕，后者不输出（实际上留在缓冲区）。原因：

`printf` 是一个格式化输出函数，功能是将格式化后的数据写入 **`stdout` 的缓冲区**。本质并不是输出到屏幕。

`stdout` 使用缓冲区（一块 RAM 区域）暂存 `printf` 写入的数据，减少直接 I/O 操作的频率，提升性能。

缓冲模式有三种：

- 无缓冲（unbuffered）：数据直接写入设备，实时显示。
- 行缓冲（line-buffered）：**终端输出时**，数据在遇到换行符 `\n` 或缓冲区满时写入设备。
- 全缓冲（fully-buffered）：输出到**文件或管道**时，数据在缓冲区满或程序结束时写入设备。

默认情况下，`stdout` 在**终端是行缓冲**，在**管道或文件输出时是全缓冲**。

所以 如果 `printf` 输出不含 `\n`, 如 `printf("%s", s.c_str());`，行缓冲模式不会触发刷新，数据**留在缓冲区**，未显示到屏幕。

缓冲区将数据传向屏幕是有条件的，如 `\n`、缓冲区满、程序结束。

所以：

- 没有 `fflush(stdout)`，数据留在缓冲区，屏幕看不到输出。
- `fflush(stdout)` **强制**（绕过上述条件）将 stdout 缓冲区中的所有数据立即写入输出设备。


## vscode 如何搜索 同时含有两个关键字的行？

- 点击启用“正则表达式”按钮（图标为 `.*`）：比如：`(?=.*hello)(?=.*bye)` 搜索同事含有 hello 和 bye 的行。
- 搜索包含"hello" 或 "bye" 的行: `hello|bye`
- 搜索“hello”后面跟着“bye”（或者中间有其他字符）的行: `hello.*bye`


## vscode ssh remote system to debug

Linux 设备只有 4GB 内存，而 VS Code debug 很容易导致该设备内存耗尽、调试崩溃。因为 Remote-SSH 模式下，VS Code 的核心服务（如语言服务器、调试器、扩展等）其实**运行在你的远程 Linux 设备上**，所以它依然会吃掉你的 4GB 内存。

解决办法：**轻量化调试**，比如将不用到的 vscode 扩展 disable 掉。【效果明显】


## Linkage [链接时的可见性]

描述了名称（如变量、函数、类等）在多个**编译单元**（.cpp 文件）之间，一个声明的名称是否可见。

1. 内部链接性（Internal Linkage）：

当名称具有内部链接性时，它只在定义它的编译单元内可见。这意味着如果两个不同的源文件中都定义了具有相同名称的内部链接性变量或函数，它们实际上是完全独立的实体。

在C++中，可以通过在**匿名命名空间**中声明名称或使用**static**关键字修饰**的全局变量或函数**来给予名称内部链接性。具有内部链接性的名称在程序的其他部分是不可见的，这有助于避免名称冲突，并提供了一种封装实现细节的方式。

2. 外部链接性（External Linkage）：

声明的名称在所有编译单元中可见。前提是它们在其他编译单元中被**适当地声明**（通常是通过包含相应的**头文件**）。**外部链接性允许不同的编译单元共享和访问相同的变量或函数**。 在 C++ 默认情况下，**非const**的全局变量和函数具有外部链接性。

**`extern` 修饰的全局变量具有外部链接（external linkage）。 所有翻译单元都可以访问同一个变量。**  这是与函数的前向声明的区别。

3. 无链接性（No Linkage）：
**局部变量**（在函数内部声明的变量）具有无链接性，它们只在定义它们的特定作用域内可见。



## 存储期类型 [声明周期]

- 自动存储期（automatic storage duration）：它的生命周期仅限于函数调用的范围内。自动构造和析构+栈分配+无需手动管理+生命周期限制
- 静态存储期（static storage duration）
- 线程局部存储期（thread-local storage duration）
- 动态存储期（dynamic storage duration）

C++中的存储期类型（storage duration types）是为了提供**不同的内存管理策略**，以**满足不同场景下对变量生命周期和作用域的需求**。存储期类型决定了变量的分配时间、生存时间、以及何时被销毁。这些类型允许程序员根据具体的应用场景选择最合适的内存管理方式。以下是C++中几种存储期类型的原因和用途：

- 自动存储期（Automatic Storage Duration）：用于**函数内部的局部变量**，这些变量在函数调用时自动创建，在函数返回时自动销毁。这种类型的变量适用于**临时数据和函数内部**的计算。
- 静态存储期（Static Storage Duration）：用于**全局变量和静态局部变量**，这些变量在程序启动时分配，在程序结束时销毁。静态存储期的变量适用于需要**在程序的整个生命周期内保持状态**的情况。
- 线程局部存储期（Thread-Local Storage Duration）：用于**线程局部变量**，这些变量对每个线程都是唯一的，并在线程开始时创建，在线程结束时销毁。线程局部存储期的变量适用于**多线程程序中需要保持线程间独立**的数据。
- 动态存储期（Dynamic Storage Duration）：用于**动态分配的变量**（如使用`new`或`malloc`分配的内存），程序员需要显式地创建和销毁这些变量。动态存储期的**变量适用于生命周期不确定或大小不固定的数据结构**。



## handle 一般是什么 [抽象的概念，它代表了一个资源]

在 C++ 中，"handle" 是一个常用的术语，通常指的是一个引用或指针，用于引用或指向另一个对象或资源。这个术语并不是 C++ 语言的一部分，而是一种编程习惯或者说是一种设计模式。例如，文件句柄（file handle）是一个常见的例子。当你打开一个文件时，操作系统会返回一个文件句柄，你可以使用这个句柄来读取、写入或关闭这个文件。在这种情况下，**句柄是一个抽象的概念，它代表了一个资源**，你可以通过它来操作这个资源，但你并**不需要知道这个资源的具体实现细节**。

另一个例子是智能指针（smart pointer）。智能指针是一种对象，它像一个指针一样工作，但当你不再需要它指向的对象时，它会自动删除这个对象。在这种情况下，智能指针是一个句柄，它代表了一个对象，你可以通过它来操作这个对象，但你并不需要管理这个对象的生命周期。总的来说，"handle" 是一种设计模式，它允许你通过一个简单的接口来操作复杂的资源，而不需要知道这个资源的具体实现细节。

