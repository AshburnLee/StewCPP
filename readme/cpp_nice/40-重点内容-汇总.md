哪些内容是重点的，面试中常考的，哪些是实战中常用的，记录在此，后续通过单独文件补充

## string

string 在内部封装了与内存和容量有关的信息，极大的减少了 c 语言中的常见的最具破坏性的错误：

- 数组越界
- 使用未初始化的 ptr 或被赋予错误值的 ptr 来方位元素
- 释放了数组内存，但是仍然保留了悬空指针

C++ 标准没有定义 string 的内存布局，各个编译器厂商可以提供不同的实现，但不许与 string 的行为一致





## 手写 unique_ptr



## 左值右值

lvalue：lvalue 存放在内存中，**有内存地址**，可以通过地址访问（比如：变量名、指针或者引用）。lvalue 可以放在赋值符号的左边，用于存储结果（因为它有内存）

prvalue：Prvalue 不在内存中，**没有内存地址**。它们有时只是在寄存器中短时间存在，有时仅仅只是逻辑上存在，实际中被优化掉了。程序员无法通过地址（变量名、指针或者引用）来访问 prvalue。 Prvalue 可以放在赋值符号右边，即： prvalue 的值可以读出来，存放在某个 lvalue 中

Xvalue 是接近生命周期末尾的 lvalue，尽管它在内存中，可以被访问，但是程序员主动放弃了对它的访问权。程序员需要显式地进行强制转换 `std::move(x)`，告诉编译器 x 不再访问。 `std::move(x)` 表达式的结果是一个 xvalue。


## 字节对齐原则，自定义字节对齐的规则  ***

内存对齐，主要是为了提高程序的性能.
对齐规则:

- 结构体的**起始存储位置**必须是能够被该结构体中最大的数据类型**所整除**。
- 每个数据成员存储的**起始位置**是自身大小的整数倍(比如 int 在32位机为4字节，则 int 型成员要从4的整数倍地址开始存储)。
- 结构体总大小（也就是 sizeof 的结果），必须是该结构体成员中最大的对齐模数的整数倍。若不满足，会根据需要自动填充空缺的字节。
- 结构体包含另一个结构体成员，则被包含的结构体成员要从其原始结构体内部最大对齐模数的整数倍地址开始存储。(比如 `struct a` 里存有`struct b`，b 里有 `char,int,double` 等元素, 那 b 应该从8的整数倍开始存储。)
- 结构体包含数组成员，比如 `char a[3]`, 它的对齐方式和分别写 3 个char是一样的，也就是说它还是按一个字节对齐。如果写：typedef char Array[3], Array这种类型的对齐方式还是按一个字节对齐，而不是按它的长度3对齐。
- 结构体包含共用体成员，则该共用体成员要从其原始共用体内部最大对齐模数的整数倍地址开始存储。

与对象的大小有关。空类空结构体占1字节

static 成员在编译时就分配好了空间，因此不会给所在结构贡献空间。

可以使用 `#pragma pack(4)` （依赖GCC编译器，非标准的，可移植性差）自定义对齐规则，制定按照 4 字节对齐，即大小是 4 的倍数就好。

C++11 新加关键字 `alignas(n)` (C++11 标准支持，可移植性好）自定义对齐规则。
)

## 数组名与指针的区别，sizeof 下分别会得到什么结果

- 指针：也是一个变量，存储的数据是地址。
- 数组名：代表的是该数组最开始的一个元素的地址。

区别：指针是一个变量，可以进行数值运算。数组名不是变量，不可以进行数值运算。

~~~cpp
int aa[5] = {1,2,3,4,5};   // 4*5=20 bytes，预分配的大小
int* i_ptr = aa;       // 8 bytes
float* f_ptr = nullptr;  // 8 bytes

cout << sizeof(i_ptr) << " " << sizeof(aa) <<"\n";
~~~

输出 8 20，所有指针的大小都是8字节，数组的大小是数组中所有元素所占大小。


## dynamic_cast 2种用法，都与多态有关。实践中避免使用

- 向下转型 (Downcasting):这是 `dynamic_cast` 最常见的用法。当您有一个指向基类的指针或引用，并且知道它实际上指向一个派生类对象时，可以使用 `dynamic_cast` 将其安全地转换为派生类指针或引用。

  ~~~cpp
  Base* basePtr = new Base();
  Base* derivedPtr = new Derived(); 

  // 向下转型
  Derived* derivedPtr2 = dynamic_cast<Derived*>(basePtr);
  derivedPtr2 = dynamic_cast<Derived*>(derivedPtr);  // cast为派生类
  ~~~

- `dynamic_cast` 可以用于在运行时确定对象的实际类型。这通常与 `typeid` 运算符结合使用。

  ~~~cpp
  class Derived1 : public Base {};
  class Derived2 : public Base {};

  Base* basePtr1 = new Derived1();
  Base* basePtr2 = new Derived2();

  // 运行时类型识别
  if (typeid(*basePtr1) == typeid(Derived1)) {
    std::cout << "basePtr1 is a Derived1" << std::endl;
  }

  if (typeid(*basePtr2) == typeid(Derived2)) {
    std::cout << "basePtr2 is a Derived2" << std::endl;
  }
  ~~~

## 宏定义以及作用
## 了解的数据结构有哪些

Array
Stack
Queue
List
Heap（一个二叉树，优先队列）

## 堆（heap）vs 栈（stack）

当说到的是内存：
全局数据区的变量都有默认的初始值 0，
而动态数据区（堆区、栈区）变量的默认值是不确定的，一般认为是垃圾值。
静态变量是存放在数据段或者 BSS 段，是不入栈的。

new & delete , malloc, realloc, calloc, free 在 heap 中开辟空间，返回的指针在 stack 中。

二者的不同：
（1）管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；
（2）空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小
（3）生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低
（4）分配方式不同。堆都是动态分配的。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由 alloca 函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。
（5）分配效率不同。栈由操作系统自动分配，会在**硬件层级对栈提供支持**，这就决定了栈的效率比较高。堆则是由 C/C++ 提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。
（6）存放内容不同。栈存放的内容，函数返回地址、相关参数、局部变量和寄存器内容等。

