
初始化和赋值时两回事，调用的函数也不同，前者调相应的构造函数，后者调赋值运算符。

===

## 拷贝构造函数

对于计算机来说，拷贝是指用一份原有的、已经存在的数据创建出一份新的数据，最终的结果是多了一份相同的数据。
在 C++ 中，拷贝并没有脱离它本来的含义，只是将这个含义进行了“特化”，是指用已经存在的对象创建出一个新的对象。从本质上讲，对象也是一份数据，因为它会占用内存。

严格来说，对象的创建包括两个阶段，首先**1.要分配内存空间，2.然后再进行初始化**：***

- 分配内存很好理解，就是在堆区、栈区或者全局数据区留出足够多的字节。表示这段空间已经预留了。

- 初始化就是首次对内存赋值，让它的数据有意义。注意是首次赋值，再次赋值不叫初始化。初始化的时候还可以为对象分配其他的资源（打开文件、连接网络、动态分配内存等），或者提前进行一些计算（根据价格和数量计算出总价、根据长度和宽度计算出矩形的面积等）等。说白了，**初始化就是调用构造函数**。通过其他对象初始化新的对象，所以拷贝构造函数也是构造函数。***

很明显，这里所说的拷贝是在初始化阶段进行的，也就是用其它对象的数据来初始化新对象的内存。

如何用拷贝的方式来初始化一个对象？例： 

~~~cpp
#include <iostream>
#include <string>
using namespace std;
// 参数 str 是按值传入的
void func(string str) {
    cout << str << endl;
}
int main() {
    string s1 = "very nice c++ tortural";
    string s2(s1);  // 调用拷贝构造函数
    string s3 = s1;
    string s4 = s1 + " " + s2;
    func(s1);
    cout << s1 << "\n" << s2 << "\n" << s3 << "\n" << s4 <<endl;
    
    return 0;
}
~~~

其中s1、s2、s3、s4 以及 func() 的形参 str，都是使用拷贝的方式来初始化的。 

对于 s1，表面上看起来是将一个字符串直接赋值给了 s1，实际上在内部进行了**类型转换**，将 `const char*` 类型转换为 `string` 类型后才赋值的。s4 也是类似的道理。

对于 s1、s2、s3、s4，都是将其它对象的数据拷贝给当前对象，以完成当前对象的初始化。

而对于 `func()` 的**形参 str**，其实在定义时就为它分配了内存，但是此时并没有初始化，只有等到调用 `func()` 时，才会将其它对象的数据拷贝给 str 以完成初始化。

当以拷贝的方式初始化一个对象时，会调用一个特殊的构造函数，就是拷贝构造函数（Copy Constructor）。

实例：见`copy_constructor.h`

~~~cpp
// 一般构造函数
Student::Student(string name, int age, float score): m_name(name), m_age(age), m_score(score) {}

// 拷贝构造函数 不是深拷贝
Student::Student(const Student& stu) {
	// ***将外部stu对象的成员 拷贝给当前对象（this）
	this->m_name = stu.m_name;
	this->m_age = stu.m_age;
	this->m_score = stu.m_score;
	cout << "copy constructor is called\n";
}
~~~

拷贝构造函数只有一个参数，它的类型是当前类的引用，而且都是 `const &`。 *** 

- 为什么必须是当前类的**引用**呢？

    如果拷贝构造函数的参数不是当前类的引用，而是当前类的对象，那么在调用拷贝构造函数时，会将另外一个对象直接传递给形参，这本身就是一次拷贝，会再次调用拷贝构造函数，然后又将一个对象直接传递给了形参，将继续调用拷贝构造函数……这个过程会一直持续下去，没有尽头，陷入**死循环**。

    只有当参数是当前类的引用时，才不会导致再次调用拷贝构造函数，这不仅是逻辑上的要求，**也是 C++ 语法的要求**。 

- 为什么是 const 引用呢？

    明确“不修改”的语义。

    另外一个原因是，**添加 const 限制后，可以将 const 对象和非 const 对象都传递给形参了**，因为非 const 类型可以转换为 const 类型。如果没有 const 限制，就不能将 const 对象传递给形参，因为 const 类型不能转换为非 const 类型，这就意味着，不能使用 const 对象来初始化当前对象了。

如果你写的拷贝构造函数参数没有 const，也可以再添加一个参数为 const 引用的拷贝构造函数，这样就不会出错了。换句话说，一个类可以同时存在两个拷贝构造函数，一个函数的参数为 const 引用，另一个函数的参数为非 const 引用。 *** 与其他运算符的构造函数一样的。


## 默认拷贝构造函数

如果程序员没有显式地定义拷贝构造函数，那么编译器会自动生成一个默认的拷贝构造函数（**目的应该与默认构造函数一样，不是给开发者方便的，而是给编译器方便的**）。这个默认的拷贝构造函数很简单，就是使用“老对象”的成员变量对“新对象”的成员变量进行一一赋值，和上面 Student 类的拷贝构造函数非常类似。

对于简单的类，默认拷贝构造函数一般是够用的，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。但是当类持有其它资源时，如动态分配的内存、打开的文件、指向其他数据的指针、网络连接等，默认拷贝构造函数就不能拷贝这些资源，我们必须显式地定义拷贝构造函数，具体是深拷贝。

## 拷贝构造和赋值运算符

~~~cpp
Student s3(s1);  // 调拷贝构造函数
Student s2 = s1; // 调拷贝运算符，用于初始化  ***
~~~

上述结果调用两次拷贝构造函数：

~~~bash
copy constructor is called
copy constructor is called
~~~

而，非初始化的赋值，不会调拷贝构造函数：

~~~cpp
Student s4("Junhui", 20, 100);
s4 = s1; // *** 调赋值运算符，用于赋值，非拷贝构造函数  ***
~~~


## 指针的拷贝

ptr1 和 ptr2 都指向同一个整数对象。如果通过 ptr1 修改了该整数的值，ptr2 也会看到这个变化，因为它们指向的是同一块内存。

指针的拷贝 仅仅拷贝了指针的值，也就是内存块的首地址。

~~~cpp
int* ptr1 = new int[10];
for (int i = 0; i < 10; ++i) {
    ptr1[i] = i*2;
}

int* ptr2 = ptr1;  // 指针的拷贝，新建一个指针类型变量b，将数据共享个b。

std::cout << &ptr1 << std::endl;
std::cout << &ptr2 << std::endl;

// ptr1 和 ptr2 指向同一个数组，所以它们的地址是一样的
for (int i = 0; i < 10; ++i) {
    std::cout << &ptr1[i] << " " << &ptr2[i] << "\n";
}

delete[] ptr1;
~~~

## 浅拷贝的一个实例

shared_ptr 就是一个典型的浅拷贝的例子。

~~~cpp
    // 拷贝构造函数 本质是浅拷贝
    self_shared_ptr(const self_shared_ptr& other) : ptr_(other.ptr_), count_(other.count_) {
        if (count_) {
            // 增加引用计数，因为共享了other的内容
            (*count_)++;
        }
    }
~~~
