## 深拷贝

对于基本类型的数据以及简单的对象，它们之间的拷贝非常简单，就是按位复制内存。

~~~cpp
class Base{
public:
    Base(): m_a(0), m_b(0){ }
    Base(int a, int b): m_a(a), m_b(b){ }
private:
    int m_a;
    int m_b;
};

{
    int a = 10;
    int b = a;  //拷贝
    Base obj1(10, 20);
    Base obj2 = obj1;  //拷贝
}
~~~

b 和 obj2 都是以拷贝的方式初始化的，具体来说，就是将 a 和 obj1 所在内存中的数据按照二进制位（Bit）复制到 b 和 obj2 所在的内存，这种默认的拷贝行为就是浅拷贝，这和调用 memcpy() 函数的效果非常类似。

对于简单的类，默认的拷贝构造函数一般就够用了，我们也没有必要再显式地定义一个功能类似的拷贝构造函数。

浅拷贝只复制原始对象的**顶层属性**的引用。如果你的对象只包含基本数据类型（例如整数、浮点数、字符串），或者包含的内部对象不会被修改，那么浅拷贝是更高效的选择。【效率考虑】

但是当类持有其它资源时，例如动态分配的内存、指向其他数据的指针等，默认的拷贝构造函数就不能拷贝这些资源了，我们必须显式地定义拷贝构造函数，以完整地拷贝对象的所有数据。

一个具体的例子来说明显式定义拷贝构造函数的必要性。我们知道，有些较老的编译器不支持变长数组，例如 VC6.0、VS2010 等，这有时候会给编程带来不便，下面我们通过自定义的 Array 类来实现变长数组。

见 `copy_deep.h` 中 Array类。

`PrintArray(const Array &arr)` 中传入 const 对象，函数体中就只能调用 const 成员，如果所调成员不是 const，则编译错.

本例中我们显式地定义了拷贝构造函数，它除了会将原有对象的所有成员变量拷贝给新对象，还会为新对象再分配一块内存，并将原有对象所持有的内存也拷贝过来。这样做的结果是，原有对象和新对象所持有的动态内存是相互独立的***，更改一个对象的数据不会影响另外一个对象，本例中我们更改了 arr2 的数据，就没有影响 arr1。

这种将对象所持有的其它资源一并拷贝的行为叫做**深拷贝**，我们必须显式地定义拷贝构造函数才能达到深拷贝的目的。

默认拷贝构造函数将 `arr1.m_p` 直接赋值给了 `arr2.m_p`，导致 `arr2.m_p` 和 `arr1.m_p` **指向了同一块内存**，所以会相互影响。这是浅拷贝。***

## 用深拷贝还是浅拷贝

如果一个类拥有指针类型的成员变量，那么绝大部分情况下就需要深拷贝，因为只有这样，才能将指针指向的内容再复制出一份来，让原有对象和新生对象相互独立，彼此之间不受影响。如果类的成员变量没有指针，一般浅拷贝足以。

另外一种需要深拷贝的情况就是在创建对象时进行一些预处理工作，比如统计创建过的对象的数目、记录对象创建的时间等，

见 `copy_deep.h` 中 Base2类。

Base2 类中的 m_time 和 m_count 分别记录了对象的创建时间和创建数目，**它们在不同的对象中有不同的值**，所以需要在初始化对象的时候提前处理一下，这样浅拷贝就不能胜任了，就必须使用深拷贝了。
