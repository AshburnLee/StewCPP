## 构造函数初始化列表

使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。

~~~cpp
class Demo{
private:
    int m_a;  // m_a 先声明
    int m_b;  // m_b 后声明

public:
    Demo(int b);
    void show();
};
Demo::Demo(int b): m_b(b), m_a(m_b){ }
~~~

在初始化列表中，我们将 m_b 放在了 m_a 的前面，看起来是先给 m_b 赋值，再给 m_a 赋值，其实不然！**成员变量的赋值顺序由它们在类中的声明顺序决定**，在 Demo 类中，我们先声明的 m_a，再声明的 m_b。所以先初始化 m_a，后初始化m_b。


## 初始化 const 成员变量

构造函数初始化列表还有一个很重要的作用，那就是初始化 const 成员变量。初始化 **非static** const 成员变量的唯一方法就是使用初始化列表。因为这是因为 const 成员变量在对象的生命周期内不能被修改，所以它们必须在对象创建时就被赋予一个值。***

初始化const 成员的方法：

1. 使用初始化列表，这是最推荐的方法
2. static const 成员变量: 如果 const 成员变量是 static 的，则可以在类声明中直接初始化。这表示该变量对所有类实例共享一个值。如：

~~~cpp
class MyClass {
private:
  static const int x = 10; // 在类声明中初始化 static const 成员变量
  ...
~~~

3. constexpr 成员变量 (C++11 及以后): 如果 const 成员变量的值在编译时已知，可以使用 constexpr 指定。这允许在编译时进行初始化。并固定下来

~~~cpp
class MyClass {
private:
  constexpr int x = 10; // 在类声明中初始化 constexpr 成员变量
  ...
~~~
