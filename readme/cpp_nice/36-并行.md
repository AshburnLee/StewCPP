
多线程编程，缺少经验

===

## 并行执行框架

实现了一个简单的并行执行框架，用于将一个循环任务分配到多个线程上执行。 

~~~cpp
inline int adjust_num_threads(int nthr, dim_t work_amount) {
    if (nthr == 0) nthr = 1;
    return (int)std::min((dim_t)nthr, work_amount);
}

static inline void parallel(int nthr, const std::function<void(int, int)> &f) {
    nthr = adjust_num_threads(nthr, INT64_MAX);

    if (nthr == 1) {
        f(0, 1);
        return;
    }

    int nthr_ = 4; // omp_get_num_threads();
    int ithr_ = 4; // omp_get_thread_num();
    assert(nthr_ == nthr);

    f(ithr_, nthr_);
}

// 在一个线程中执行循环任务
static inline void for_nd(const int ithr, 
                          const int nthr, 
                          dim_t D0, 
                          const std::function<void(dim_t)> &f) {
    dim_t start {0}, end {0};
    balance211(D0, nthr, ithr, start, end);  //
    for (dim_t d0 = start; d0 < end; ++d0)
        f(d0);
}

static inline void parallel_nd(dim_t D0, const std::function<void(dim_t)> &f) {
    int nthr = adjust_num_threads(1, D0);
    if (nthr)
        parallel(nthr, [&](int ithr, int nthr) { for_nd(ithr, nthr, D0, f); });
}
~~~

上述细节：
1. `std::function` 是一个函数对象包装器，可以用于存储任何可调用对象（例如，函数指针、lambda 表达式、函数对象）。
2. `f(0, 1)` 表示在当前线程中执行函数 f，线程 ID 为 0，总线程数量为 1。
3. `balance211` 函数用于将循环任务均匀地分配到多个线程上。 这种任务分配方式可以尽量保证每个线程的工作量相等，从而避免某些线程过载，而另一些线程空闲的情况。

线程安全和异常处理

## 多线程同步点

多线程执行的代码中，用于保护竞争资源的方法，使得每个线程单独访问 竞争资源

~~~cpp
// Synchronization point
static std::mutex m;
std::lock_guard<std::mutex> guard(m);
...
~~~

实例：

`std::lock_guard` 用于保护 `globalCounter` 的访问, 每个线程在进入临界区时会**锁定**互斥锁，执行计数器的增加操作，然后在作用域结束时，`std::lock_guard` 的析构函数会自动释放互斥锁。这样确保了每个线程在执行关键操作时都拥有独占的访问权限，避免了竞态条件，从而保证了计数器的正确递增。

~~~cpp
#include <iostream>
#include <thread>
#include <mutex>

std::mutex m;
int globalCounter = 0;

void incrementCounter(int threadId) {
    {
        std::lock_guard<std::mutex> guard(m);
        // 在这个作用域中，互斥锁已经被锁住
        for (int i = 0; i < 5; ++i) {
            std::cout << "Thread " << threadId << ": Incrementing counter. Current value: " << ++globalCounter << std::endl;
        }
    }
    // 在这个作用域结束时，std::lock_guard 的析构函数会自动释放互斥锁
}

int main() {
    // 创建两个线程，并让它们增加计数器的值
    std::thread t1(incrementCounter, 1);
    std::thread t2(incrementCounter, 2);

    // 等待两个线程执行完成
    t1.join();
    t2.join();

    return 0;
}
~~~

临界区（`Critical Section`）是一段只能由一个线程在同一时间执行的代码。临界区通常包含访问共享资源（如数据结构、文件、数据库连接等）的代码，这些资源可能会在多个线程之间产生竞争条件（`Race Condition`），导致数据不一致或其他错误。

对于 `std::lock_guard<std::mutex> guard(m);`,

- 如何理解 `m` : `m` 是 `std::mutex` 类型的对象，用于同步对共享资源的访问。 **当一个线程获得互斥锁 `m` 的所有权时，其他线程就无法再获取该锁，直到拥有锁的线程释放它。** ***

- 编译器如何做？`std::lock_guard` 的构造函数会在内部调用 `m.lock()` 方法来尝试获取互斥锁 `m` 的所有权。 如果 `m` 已经被其他线程锁定，则当前线程会阻塞，直到 `m` 被释放。 [RAII]


## std::call_once   [多线程中执行一次]

~~~cpp
std::once_flag flag;
void initialize_resource(){}
std::call_once(flag, initialize_resource);
~~~

表示在多线程环境中只执行一次，需要与一个 `std::once_flag flag`; 一起使用，其用于表示这个函数是否已经被调用。
