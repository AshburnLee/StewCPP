
# 数据结构 查漏补缺

- ADS 是抽象数据结构，定义了数据结构的接口和行为，而不涉及具体的实现细节。抽象数据结构关注的是数据结构的功能和操作。Array, Stack，Queue，List, Set, Map, Tree...
- 实现：是某一个 ADS 的具体实现，一个 ADS 不同的实现有其优缺点和适用场景。array, linked list, binary tree, hash table, binary search tree...
- C++  标准库中的都是具体实现。
- ADS 的一个实现比另一个实现好？没有这种说法，需要看你的应用场景。

## ADS 数组

- std::array 实现了一个固定长度的数组，长度在编译时确定。
- std::vector 实现了动态长度数组。
- `int arr[10]`: C-style 的实现;

- 如何确定动态数组的长度？给定一个长度值 `MAX_LENGTH`，当实际长度超过这个值时，新建一个数组，将其长度设为 `2*MAX_LENGTH`。拷贝元素组内容到新数组，然后释放原数组资源。
- 操作：创建空数组，add，insert，remove，count，read/modify，指定数据类型，所以动态数组**元素位置一定是连续的**。
- 内存对齐：根据数据类型，确定首地址位置 & 内存对齐。
- 成熟的动态数组实现：std::vector
- std::vector 的**默认长度由编译器确定**。当使用默认构造函数时，长度是0，它不分配任何内存，直到你添加第一个元素。当你的 std::vector 需要存储的元素数量超过其当前容量时，它会自动重新分配内存。
- std::vector 需要存储的元素数量超过其当前容量时，要做耗时操作：**分配更大的内存块，赋值元素，释放旧内存**。
- std::vector 所以为了提高效率，使用 `reserve()` 方法预先分配内存。注意他还有 `capacity` 属性.
- std::vector 的数据存储在堆（heap）上，而不是栈（stack）上。


## ADS 列表 List

- `LinkedList` 是动态数组，长度动态变化。弥补了 `std::vector` 的缺点。
- `LinkedList` 一个节点包含当前数据 & 下一个位置的地址。（一个指针占 4B），所以在内存中的一个节点的大小包括了这个地址的大小，所以 `LinkedList` 的示意图和在内存中的表示可以理解为是相同的。这个 “相同” 就很直观表示了链表的 `next` 指针，以及 `node->next` 真正是什么意思。***
- C++ 表标准库中 `std::list` 实现了 Double LinkedList。`std::forward_list` 实现了单向链表。你也可以有自己的实现，比如 `struct LinkedList`。


## ADS Stack

- 应用场景：undo 撤销操作，编译器中的括号匹配
- 操作：`push()`，`top()`，`pop()`，`isempty()`
- 底层实现：使用数组 Array，逻辑是将 top 指针指向最后一个位置。当初始化 stack 时，首先 top 指针或位置在 -1，,当需要 `push()` 一个元素 x 时，先 `top++`， 然后在 `array[top] = x`；当需要 `pop()` 一个元素时，只需要 `top--` ；当 `top()` 时，返回 `array[top]` 即可。同样的，当 `push()` 元素个数超过 array 长度时（overflow），需要 创建一个2倍长度的新数组，拷贝旧数组到新数组，然后释放旧数组。

- 底层实现：使用链表，当把 list 尾作为栈顶时，`push()` 和 `pop()` 都是耗时的，O(N)。当把 list 的头作为栈顶时，push() 和 pop() 都是耗时的，O(1)。push() pop() 操作就是链表中插入和删除节点的操作。链表实现不会存在overflow。

- stack 应用场景：当需要获取一个序列的逆序时。还可以 reverse 一个链表。
- stack 应用场景：infix，prefix，postfix 相互转换（编译器是主要应用场景）。

- 给出 postfix，计算表达式值 [记住这个逻辑]
    
    实际上，这种表达计算结果是非常快和直接的。使用一个 只存储操作数的 stack 就可以了（https://www.youtube.com/watch?v=MeRb_1bddWg&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=20）。 （手动走一遍就明朗了）

- 给出 prefix，计算表达式值。这时需要从 prefix 的右向左遍历，并同样的，维护一个只含有操作数的stack。（手动走一遍就明朗了）

- infix 转换为 postfix. [记住这个逻辑]

    根据操作符优先级，加括号；然后转换；最后删除括号。手动疏通逻辑，再实现。(https://www.youtube.com/watch?v=vq-nUF0G4fI&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=21) 。实际上应该记住这个逻辑。


## ADS Queue

- FIFO 操作: `Enqueue()`， `Dequeue()`,  `Front()`,  `isEmpty()`
- 用 array 实现，关键是 front 和 rear ， enqueue 时，移动 rear， dequeue 时 移动 front。
- 在 enqueue 和 dequeue 过程中，array 中前部的位置会被浪费，因为都 Dequeue 出去了。为了避免这个浪费，使用**循环队列**，它本身还是一个 array ， 只是对于当前位置 idx ， 下一个不是 `idx+1`， 而是 `(idx+1) % array.length`, 如此就可以一直循环下去，不会浪费头部空间，但是总的长度就动态增长了。

- std::queue 是容器适配器，是ADS queue的实现
    注意：在 C++ 标准模板库 (STL) 中，容器适配器 (Container Adapter) 是一种特殊的容器，它不直接管理底层数据存储，而是通过包装另一个 STL 容器（例如 std::vector、std::deque 或 std::list）来提供特定接口和行为。 **它们不提供自己的数据存储机制，而是依赖于底层容器来存储元素。 容器适配器限制了底层容器的功能，从而提供了一种更受限、更专门化的接口，适合特定用途。**

    **容器适配器**与**第一类容器**的区别：

    第一类容器（例如 std::vector、std::list、std::map 等）**直接管理其元素的存储和访问**。 它们提供丰富的接口，允许您以各种方式操作元素，例如迭代、随机访问、插入和删除等。

    容器适配器则不同，它们**提供更受限的接口，只允许执行特定操作**，例如在栈中 push() 和 pop() 元素，或在队列中 push()、pop()、front() 和 back()。 它们不提供迭代器，也不允许随机访问元素。 这种受限的接口保证了特定数据结构的行为，并提高了代码的可读性和可维护性。

- 链表实现 Queue 时，比如我定义从头处 Dequeue，尾处 Enqueue。为了 Enqueue 时不总是从头开始找尾，**事先定义一个 Rear 节点**，指向之后一个节点，如此一来，构造初始化时，只要一次遍历即可找到尾节点 的位置，之后的操作始终保证Rear 在尾部，如此就不需要频繁地遍历找尾节点。实际上，初始化时，元素个数是零，所以根本不需要遍历找到 rear 节点。注意一点：list 头部 Dequeue 时，记得将 Dequeue 的节点释放。


## ADS Tree -> Binary Tree -> BST

BST 用于存储有序序列.

- 满（perfect）二叉树节点个数：`n=2^(h+1) - 1`，h是数的高度。
- 完全（complete）二叉树除了最后一层，是一个满二叉树，最后一层的节点无空隙地左侧对其。
- 遍历：先序（根左右）中序（左根右）后序（左右根）

## 双端队列

- std 中 使用 `std::deque` （double end queue），可以两端 push 和 pop
- 操作：`push_front()`, `push_back()`, `pop_front()`, `pop_back()`



# Insight ***

- 递归实现，为了便于理解，递归函数中调用自己的地方，你应该理解为这个子问题已经被解决了，基于此，处理当前问题。
- 回溯：实现中 一定会有“回” 的体现。“进”与“回”之间有循环

# 相关知识

中缀、前缀和后缀表示法是表示算术表达式的三种不同方式。它们的区别在于运算符相对于操作数的位置。

- 中缀表示法 (Infix Notation): 这是我们最熟悉的表示法，运算符位于操作数之间。例如：2 + 3，5 * (2 + 1)。 这是日常数学和大多数编程语言中使用的标准表示法。 它需要括号来指定运算顺序，并且遵循运算符优先级规则。人可读。

- 前缀表示法 (Prefix Notation) / 波兰表示法 (Polish Notation): 运算符位于操作数之前。例如，+ 2 3 等同于中缀表示法的 2 + 3；* 5 + 2 1 等同于中缀表示法的 5 * (2 + 1)。 前缀表示法不需要括号，运算顺序由运算符的位置完全确定。机器可读。

- 后缀表示法 (Postfix Notation) / 逆波兰表示法 (Reverse Polish Notation): 运算符位于操作数之后。例如，2 3 + 等同于中缀表示法的 2 + 3；5 2 1 + * 等同于中缀表示法的 5 * (2 + 1)。 与前缀表示法一样，后缀表示法也不需要括号，运算顺序由运算符的位置完全确定。机器可读。

操作符号的优先级：

1. 括号（）{} []
2. 指数（从右向左）
3. 乘除（从左向右）
4. 加减（总做向右）
 

## 如何理解动态规划

  - 最优子结构： 如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构。动态规划利用这一性质，通过求解子问题的最优解来构建原问题的最优解。
  - 重叠子问题： 在递归求解过程中，很多子问题会被重复计算多次。动态规划通过将这些子问题的解存储起来（通常在一个表或数组中），从而避免了重复计算，显著提高了效率。
  - 状态转移方程： 动态规划中的状态转移方程描述了如何从子问题的最优解推导出原问题的最优解。这个方程是动态规划算法的核心，它定义了问题状态之间的转移关系。
  - 边界条件： 边界条件（或初始条件）是动态规划算法的基础，它定义了最小子问题的解。从这些边界条件出发，算法逐步构建出更大问题的解。

动态规划问题的基本思考

  - 分析问题结构： 确定问题是否具有最优子结构和重叠子问题，这是应用动态规划的前提。
  - 定义状态： 将问题的每个阶段定义为一个状态，通常用一个或多个变量来表示。
  - 状态转移方程： 根据问题的性质，建立状态之间的转移方程。这个方程描述了如何从当前状态转移到下一个状态。
  - 计算最优解： 从边界条件开始，利用状态转移方程逐步计算出各个状态的最优解，直至得到原问题的最优解。

DP 实战中，问自己：

  - 定义状态: dp[i] 或 dp[i][j] 等表示什么含义？
  - 状态转移方程: 如何从之前的状态推导出当前状态？
  - 初始状态: dp[0] 或 dp[0][0] 等的初始值是什么？


## XOR 异或 ^

Exclusive OR。一种逻辑运算符，作用于两个布尔值（或二进制位）上。异或运算的结果如下：

- 两个操作数相同（都是 0 或都是 1），则结果为 0。
- 两个操作数不同（一个是 0，一个是 1），则结果为 1。

## 堆排序 Heap

性质树形数据结构，堆的性质：最大堆中，父节点的值总是大于或等于其子节点的值；

步骤：1，heapfy 2，排序（提取堆顶元素，减少堆的大小，Heapify）

复杂度与优劣：时间复杂度是O(N.logN)，空间复杂度为 O(1) (原地排序)，因为它只需要常数个额外空间。 虽然时间复杂度与快速排序相同，但在最坏情况下，堆排序的性能更稳定，不会像快速排序那样出现 O(n²) 的情况。 但是，堆排序的常数因子通常比快速排序大，因此在实际应用中，快速排序通常更快，除非需要保证最坏情况下的性能。

应用场景：在 100M 个数中找到前 100 个元素，


## 使用数组表示二叉树

使用数组表示二叉树，数组需要满足一定的性质，才能正确地反映二叉树的结构和节点之间的关系。 这些性质主要取决于你选择哪种数组表示法。 最常见的是**层序遍历**表示法。

层序遍历表示法是最常用的方法。 数组中的元素按照二叉树的层序遍历顺序排列。 这意味着：

- 根节点: 数组的第一个元素 (索引 0) 总是根节点。
- 左子节点: 如果父节点的索引是 i，则其左子节点的索引是 **2i + 1**
- 右子节点: 如果父节点的索引是 i，则其右子节点的索引是 **2i + 2**
- 空节点: 为了表示空节点，通常使用一个特殊的值（例如 -1，NULL，或一个很大的负数）。 这对于非完全二叉树至关重要。

对于完全二叉树，数组表示法非常高效，因为没有空节点需要特殊处理。 数组大小等于节点数量。


## 补充-常数因子

在算法分析中，“常数因子”指的是算法运行时间表达式中的常数项。大O表示法只关注算法运行时间的增长趋势，忽略了常数因子和低阶项。

常数因子来源于算法中的基本操作次数。 例如，堆排序需要进行更多的比较和交换操作才能完成排序，而快速排序在平均情况下需要的操作次数较少。 这些操作次数的差异就体现在常数因子中。 具体来说，这些操作包括（常数因子来自）：

1. 比较: 算法中元素之间进行比较的次数。
2. 交换: 算法中元素之间进行交换的次数。
3. 内存访问: 算法访问内存的次数（这与缓存命中率有关，缓存命中率低会显著增加运行时间）。
4. 函数调用: 算法中函数调用的次数。

这些操作的次数在不同算法中差异很大，这些差异就体现在常数因子中。 




## 单调栈 leetcode 739

dev.ai 解答了我的困惑【**真诚地表达你的疑惑，dev.ai 会进一步给你解释**】：

即使知道栈中存储的是索引，仍然难以想到正确的逻辑判断，这很正常。这通常是因为缺乏对单调栈**核心性质**的深刻理解，以及**问题转化**的技巧。

1. 核心性质：单调递减栈的意义

  - **栈中索引的温度，是“潜在的、尚未找到更大值的元素”。** 也就是说，对于栈中的每一个索引 j，temperatures[j] 都还在等待一个比它更大的值出现。
  - **栈底到栈顶，索引对应的温度是始终递减的**。 这意味着，越靠近栈顶的元素，是越“新”的潜在更大值等待者。如果一个较早的 temperatures[j] 找到了更大的值，那么晚于 j 入栈的元素也一定会被考虑到。

2. 问题转化：**从“找更大值”到“维护单调性”**

  - 原始问题： 对于每个 `temperatures[i]`，找到它后面第一个比它大的值。
  - 转化后的问题： 维护一个栈，使得栈中的元素（对应的温度）保持递减。当遇到一个更大的值时，它会“消灭”栈中所有比它小的“等待者”。

`temperatures[stack.top()]` 是栈顶索引对应的温度，也就是最近一个“等待更大值”的温度。
如果 `temperatures[i]` > `temperatures[stack.top()]` 成立，说明 `temperatures[i]` 找到了比 `temperatures[stack.top()]` 更大的值！
因此，可以安全地弹出 `stack.top()`，并记录结果。

## DFS

基本原理：

~~~sh
DFS(节点 v):
    标记 v 为已访问
    对于 v 的每个邻居节点 u:
        如果 u 未被访问:
            DFS(u)
~~~

其中的关键是：标记已访问

树是一种特殊的图，它没有环（cycle）。这意味着从任何一个节点出发，不可能通过一系列的边回到该节点自身。故不需要标记已访问。

【done】Number of Islands
【done】Combination Sum
【done】Longest Increasing Path in a Matrix， DP 可以解决


## 图 联通分量

NumberOfIsland 本质上就是求图中的联通分量。

## 如何判断是DP问题？

1. 通常解决最优化的问题。
2. DP的核心特性是存在重叠子问题，即在解决问题过程中，相同的子问题会被计算多次。
3. 无后效性：当前状态一旦确定，就不会受到后续决策的影响。

**DP 问题都可以画出递归树**，其中每个节点代表一个函数调用，节点的孩子代表该函数调用所产生的子调用。在递归树中，你能发现有相同的子问题被多次计算。通过分析递归树，可以更容易地推导出动态规划的状态转移方程。

## 0-1 背包问题

你有一个背包，它的容量是有限的（比如 W）。现在你有一堆物品，每个物品都有自己的重量（wi）和价值（vi）。你的目标是选择哪些物品放入背包，使得在不超过背包容量的前提下，背包中物品的总价值最大。

关键点在于“0-1”：每种物品你只能选择**要么不放入背包（0），要么放入一个（1）**。


## 完全背包问题

完全背包问题与 0-1 背包问题类似，但有一个重要的区别：**每种物品你可以选择放入背包的数量没有限制**。也就是说，对于每种物品，你可以选择放入0个、1个、2个，等等，只要不超过背包容量即可。


## HUAWEI

leetcode 上关 medium 难度的题目，可以通过穷举法提供一个解法，但有更优的解法。这样的题目给出3个与 dfs 相关的。
leetcode 上关 medium 难度的题目，可以通过穷举法提供一个解法，但有更优的解法。这样的题目给出3个与 bfs 相关的。
leetcode 上关 medium 难度的题目，可以通过穷举法提供一个解法，但有更优的解法。这样的题目给出3个与 dp 相关的。

Knapsack Problem
Longest Common Subsequence, LCS
