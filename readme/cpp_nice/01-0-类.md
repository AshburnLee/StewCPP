## 对类的基本认识

类是蓝图，对象是实例： 类只是一个蓝图或模板，定义了对象的结构和行为。它本身并不占用内存空间。只有当创建类的对象（实例）时，才会**分配内存**来存储对象的数据。定义类时可以初始化成员，通过初始化列表，类内初始化，构造函数初始化。

在栈上分配内存：栈上创建的对象都有名字。栈内存管理自动进行，当函数结束或作用域结束时，栈上的对象会被自动销毁。 

~~~cpp
Student stu;
Student *p_stu = &stu;
~~~

在堆上分配内存：堆上创建的对象是匿名的，所以**必须**用一个 pointer 指向它，否则就找不到这个对象了，使用 new 创建的对象是匿名的。

~~~cpp
Student *p_stu = new Student;
~~~


## 计算一个类的大小

类的声明没有大小，类对象才有大小。`sizeof(A)` 计算的是编译器需要为 A 类型的一个实例分配多少内存。***

在使用 `sizeof` 计算类的对象大小时，遵循以下几条规则：

1. **空类对象**占一字节，这一字节其实是占位符，编译器分配给该对象的，而不是该对象中存有数据。

2. 基本成员函数（虚函数除外）不占空间；

3. 成员变量占空间，大小为其类型自身大小（比如int型成员变量就会占用4字节），但是多个成员变量的空间之和要遵循一定的对齐规则：总空间大小是各类型（包括虚指针）中占空间最大那个的整数倍。比如 class A， 其对象就会占用 8 字节的空间，因为 int 为 4 字节，char 为1一字节，所以总大小一定是4的整数倍，4+1=5，所以应该是8字节：

    ~~~cpp
    class A{
        int a;
        char b;
    }
    ~~~

4. 如果类中有**虚函数**，编译器会自动添加一个隐藏的虚函数表指针（`vptr`）作为类的第一个成员（这个指针的大小取决于系统的位数 (4字节或8字节)），这里需要注意的是，不管有几个 虚函数都只存在一个虚指针，因为 `vptr` 指向一个虚函数表 (虚函数表（`vtable`）在编译时产生，存在只读数据段或常量数据段，当程序调用虚函数时，它会首先通过 `vptr` 找到 `vtable`， 然后从 `vtable` 中找到要调用的函数的地址。)，那里存在各个虚函数对应的地址。***

4. 每个包含虚函数的类对象都会隐式地包含一个指向其虚函数表的指针 (`vptr`)。这个指针才是实际占用对象空间的部分。

5. 派生类的对象大小 = 基类中各个成员总大小 + 自己类中各个成员总大小

6. 静态成员。类的静态成员变量被放在**全局区**，并没有和类的普通成员放在一起。类的静态成员**被声明后就已存在**，而非静态成员只有类被实例化后才存在。所以下面类 A 的大小为 sizeof(int)=4

    ~~~cpp
    class A{
        int a;
        static char b;
    }
    ~~~


## 多态

多态是面向对象的重中之重，以封装和继承为基础

- 继承一：https://ashburnlee.github.io/2019/09/05/%E5%9B%9E%E9%A1%BEcpp-%E7%BB%A7%E6%89%BF-%E4%B8%80/
- 继承二：https://ashburnlee.github.io/2019/09/08/%E5%9B%9E%E9%A1%BEcpp-%E7%BB%A7%E6%89%BF-%E4%BA%8C/

- 多态

  - [虚函数](https://ashburnlee.github.io/2019/08/28/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%B8%80-%E8%99%9A%E5%87%BD%E6%95%B0/)
  - [虚函数表](https://ashburnlee.github.io/2019/08/29/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%BA%8C-%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/)
  - [接口类](https://ashburnlee.github.io/2019/08/30/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E4%B8%89-%E6%8E%A5%E5%8F%A3%E7%B1%BB/)
  - [RTTI](https://ashburnlee.github.io/2019/08/31/%E5%9B%9E%E9%A1%BEcpp-%E5%A4%9A%E6%80%81-%E5%9B%9B-RTTI/)



如果一个父类要具备多态的性质，都应该为他声明**virtual析构函数**；如果一个 class 含有任何 `virual` 函数，就一定要有一个 `virtual` 析构函数，这通常是一个好习惯。

而如果这个 class 的设计不是作为基类使用，或者不准备让这个 class 具备多态性，就不该声明 `virtual` 析构函数。

含有多态性质的 base class 的设计目的是为了通过 base class 的接口来使用 derived class。所以通常使用 base class 类的指针指向 derived class 的对象。

并不是所有的 base class 都是为了多态用途，比如 `STL` 容器的设计不是用作 base class 的。

`virtual` 同名函数的目的是允许 derived class 的实现可以**客制化**，即调用自己的同名函数。


- 虚函数的代码本身只存储一次，位于**代码段**中。
- 每个包含虚函数的**类对象**都会包含一个指向虚函数表的指针 (vptr)，这个指针占用对象空间。 这通常是4或8字节。
- 虚函数表 (vtable) 存储在**数据段**中，不属于对象本身。


## 析构函数

析构函数没有参数，不能重载，因此，一个类只有一个析构函数。

## 析构函数的执行时机

析构函数在对象被销毁时调用，而对象的销毁时机与对象所在是内存区域有关：

- 全局对象，在所有函数外创建的对象。与全局变量类似，位于**全局数据区**，所以在程序结束时才会调用析构函数。
- 局部对象，在函数内部创建的对象。与局部对象类似，位于**栈区**，函数执行结束时调用对象的析构函数。
- new 创建的对象位于**堆区**，通过 delete 删除对象时才会调用析构函数；如果没有 delete，析构函数就不会被调用。


## struct & class

class 和 struct 都可以使用模板。

## 类本身就是个作用域

在类的作用域之外，

- **普通的成员**只能通过类对象访问，
- **静态成员**可通过类对象或者类本身访问；这是因为静态成员属于类本身，而不是特定对象实例。
- **typedef 定义的类型**：typedef 本身并不创建新的作用域。它只是为现有类型创建了一个别名。因此，typedef 定义的类型与它所代表的类型的访问规则相同。


## 常成员对象

const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）了。因为非 const 成员可能会修改对象的数据（编译器也会这样假设），C++禁止这样做。***

const 成员函数承诺不修改类中非 mutable 的成员。



~~~cpp
class Student{
public:
    Student(char* name, int age, float score);
public:
    void show();
    char* getname() const;
    int getage() const;
    float getscore() const;
private:
    char* m_name;
    int m_age;
    float m_score;
};

Student::Student(char *name, int age, float score): m_name(name), m_age(age), m_score(score){ }
void Student::show(){
    cout<<m_name<<" age is: "<<m_age<<", score is: "<<m_score<<endl;
}
char* Student::getname() const{
    return m_name;
}
int Student::getage() const{
    return m_age;
}
float Student::getscore() const{
    return m_score;
}

int main(){
    const Student stu("Xioaming", 15, 90.6);
    //stu.show();  //error
    cout<<stu.getname()<<"age is: "<<stu.getage()<<", score: "<<stu.getscore()<<endl;

    const Student *pstu = new Student("Lilui", 16, 80.5);
    //pstu -> show();  //error
    cout<<pstu->getname()<<"age is: "<<pstu->getage()<<", score: "<<pstu->getscore()<<endl;
    return 0;
}

~~~

因为`show()` 不是`const`成员，所以不能被`const` 对象或对象指针调用。

## mutable

mutable 关键字允许在 const 成员函数中修改特定的成员变量。这在某些情况下非常有用，因为你可能希望在 const 函数中修改某些与类状态无关的数据成员，而不影响类的主要状态。例：

~~~cpp
class MyClass {
public:
    int getSomething() const {
        callCount++; // 可以在const函数中修改
        return something;
    }
    int getCallCount() const {
        return callCount;
    }
private:
    int something;
    mutable int callCount = 0; // mutable变量
};
~~~

## 嵌套类

嵌套类 (nested class) 指的是在一个类内部定义的另一个类。 有时也称为封闭类 (enclosed class)，指的是被嵌套的内部类。 外部的类被称为封闭类 (enclosing class) 或外部类。

嵌套类主要用于组织代码，增强封装性，以及避免命名空间污染。

## 避免创建匿名对象

`(new Student("Michael", 90))->Show();` 创建匿名对象，非最佳实践。问题在于内存管理：你动态分配了 Student 对象，但没有释放它，导致内存泄漏。

最佳实践：

1. 在 stack 上创建对象
2. 使用智能指针，它是 RAII 的，不需手动管理内存：

    ~~~cpp
    std::unique_ptr<Student> student = std::make_unique<Student>("Michael", 90);
    student->Show(); // 使用 -> 访问成员函数
    ~~~


## 类的元数据

编译器在编译阶段，除了维护符号表，还会**为每一个类维护一个类的元数据(meatadata)**。metadata 维护了类的结构和属性的信息。具体包括：

- 类名：类的名称。

- 基类信息：类的继承关系，包括基类和派生类的信息。

- 成员变量：类的成员变量的名称、类型、访问权限（public、protected、private）等。

- 成员函数：类的成员函数的名称、返回类型、参数类型、访问权限等。

- 构造函数和析构函数：类的构造函数和析构函数的信息。

- 访问控制：类的访问控制信息，包括友元类和友元函数。

- **vtable**：如果类包含虚函数，编译器会生成虚函数表（`vtable`），并在元数据中记录虚函数表的指针。用于支持多态和动态绑定。

- 模板参数：如果类是模板类，元数据中会包含模板参数的信息。

- 内存布局：类的内存布局信息，包括成员变量的偏移量、类的大小、对齐要求等。

运行时，类的元数据不会直接保存在目标文件中，但是对于包含**虚函数的类**，编译器会生成**vtable**，并且在目标文件中保留**vptr**。
