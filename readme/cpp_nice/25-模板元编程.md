# 模板元编程 TMP

模板元编程 (Template Metaprogramming): 在**编译时进行代码生成**的编程技术。它将模板当作一种“编译时编程语言”，通过递归、特化和类型推导等手段，在编译阶段完成复杂的计算或生成代码，而不是在运行时执行。

模板参数是在**编译时确定**的。这是模板元编程的**核心概念**。 编译器会根据你提供的模板参数，生成特定的代码。这个过程称为**模板实例化**. 编译器会**为每组不同的模板参数生成一份独立的代码**。 

无运行时开销，在编译时就已经检查类型了，运行时类型是安全的。 所以缺点是 模板可能导致代码膨胀。使得可执行文件很大。




# traits 机制 [模版元编程]

c++ 模板中的 traits 什么意思，应用在什么场景？在工业界找出实例

c++ 模板中的 traits 是一种编程技术，用于在**编译时获取类型信息**。它可以帮助我们**在模板中根据类型的特性进行不同的处理**。traits 可以应用在很多场景，比如：

1. 类型萃取： 通过 traits 可以从一个类型中提取出特定的信息，比如类型的大小、成员函数、成员变量等。这样我们可以根据这些信息来进行不同的操作。
2. 类型转换： traits 可以帮助我们进行类型转换，比如将一个类型转换为另一个类型，或者将一个类型转换为字符串等。
3. 模板特化： traits 可以用于模板特化，通过为不同的类型提供不同的traits实现，可以在模板中根据类型的特性进行不同的处理。

实例：
~~~cpp
/*
定义了一个名为 is_integer 的模板结构体。它接受一个类型参数 T。默认情况下，value 成员变量被设置为 false，表示类型 T 不是整数类型。
*/
template <typename T>
struct is_integer {
    static constexpr bool value = false;
};

// Specialization for integer types 特化
/*
对 is_integer 模板进行了特化。当类型参数 T 为 int 时，value 成员变量被设置为 true，表示 int 类型是整数类型。 
*/
template <>
struct is_integer<int> {
    static constexpr bool value = true;
};

// Usage example
void foo() {
    if (is_integer<int>::value) {
        // Do something for integer types
    } else {
        // Do something for non-integer types
    }
}
~~~

关键概念:

- Traits 是模板元编程的重要组成部分。
- 特化 (Specialization): 为模板提供特定类型的自定义实现。这允许我们**为不同的类型提供不同的行为**。
- `constexpr`: 表示一个常量表达式，可以在编译时计算其值。这使得 `is_integer::value` 可以直接在 if 语句中使用。***
- 编译时信息 (Compile-time information): 在编译阶段就已知的信息。Traits 允许我们访问和利用这些信息。

注意：考虑使用标准库中的 <type_traits> 头文件，其中包含了 `std::is_integral` 等现成的 traits，避免重复造轮子。




# remove_pointer & typename   [模板元编程范式]

`std::shared_ptr<typename std::remove_pointer<T>::type> data_ {0};`

1. `std::remove_pointer` 是一个模板元编程工具。它用于从一个指针类型中获取指针所指向的实际类型。具体来说，`std::remove_pointer<T>` 用于从类型 T 中移除指针，返回实际的类型。通过这个移除指针操作，你可以获取到指针所指向的类型，即 T 的**基础（去指针）类型**

2. `typename` 是一个关键字，用于在模板中**指示一个名称是一个类型**而不是其他**实体**（如变量或函数）。它通常用于访问依赖于模板参数的嵌套类型。在代码片段中，`typename` 用于标识其后 `std::remove_pointer<T>::type` 是一个类型。这是因为 `std::remove_pointer<T>::type` 是一个依赖于模板参数 T 的嵌套类型，而 **`typename` 告诉编译器它是一个类型名**。

注意，使用 `typename` 不仅适用于 `std::remove_pointer<T>::type`，在其他上下文中（如嵌套类型别名、模板参数推导等），当**需要明确表明某个名称是一个类型时，也需要使用 typename 关键字**。

