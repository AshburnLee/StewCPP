

## 单例设计模式

什么是单例设计模式？含有哪些组件？给出C++实例【框架的各个backend都是一个单例的类】

单例设计模式是一种创建型设计模式，它**确保类只有一个实例**，并提供全局访问点（getInstance）。 在C++中，可以通过将构造函数声明为私有的并提供一个静态方法来实现单例模式。

组件:
  1. 将构造函数声明为私有的，以防止外部创建实例
  2. 静态成员变量，用于保存单例实例
  3. 静态方法，用于获取单例实例

~~~cpp
class Singleton {
public:
  // 3. 静态方法，用于获取单例实例
  static Singleton* getInstance() {
    // 如果实例不存在，则创建一个新实例
    if (instance == nullptr) {
      instance = new Singleton();
    }
    return instance;
  }

  // 其他公共方法
  void doSomething() {
    // ...
  }

private:
  // 1. 将构造函数声明为私有的，以防止外部创建实例
  Singleton() {}

  // 2. 静态成员变量，用于保存单例实例
  static Singleton* instance; // static 成员属于类本身，而不属于类的任何对象
};

// 初始化静态成员变量
Singleton* Singleton::instance = nullptr;
~~~

单例模式的应用场景：当一个类只需要存在一个实例时，可以使用单例模式。例如，一个系统中只需要存在一个日志记录器，可以使用单例模式来实现。以下是一个使用 C++ 实现的单例模式示例：

~~~cpp
class Logger {
public:
    static Logger& get_instance() {
        static Logger instance;
        return instance;
    }

    void log(const std::string& message) {
        // log the message
    }

private:
    Logger() {}
    Logger(const Logger&) = delete;
    Logger& operator=(const Logger&) = delete;
};
~~~

## 方法链式  [返回指向当前对象的指针]

~~~cpp
class MyClass {
  public:
    MyClass& setX(int x) {
      this->x = x;
      return *this;
    }
    MyClass& setY(int y) {
      this->y = y;
      return *this;
    }
  private:
    int x, y;
};

MyClass myObject;
myObject.setX(5).setY(10);
~~~
