
1. 寄存器有名字，不需要寻址
2. 右值是临时数据，没有内存地址，无法获取其地址
3. 常量表达式没有地址，它属于代码的一部分

===

## 寻址

指针变量存的是数据或代码在内存中的地址，指针指向的就是内存中的数据或代码。这里要强调“内存”，就是说指针只能指向内存，不能指向寄存器或硬盘，应为后两者没法**寻址**。

其实 C++ 中大部分代码都是存放在内存中的，如变量、常量、对象、函数体、函数形参、`new()` 或 `malloc()` 分配的内存等。**这些内容都可以用 `&` 来获地址**。进而用指针指向他们。

除此之外，还有其他数据，比如：表达式的结果、函数返回值等，他们可能会放在内存中，也可能存放在寄存器中。**一旦它们被放到寄存器中，就没有办法用 `&` 来获取他们的 地址了。**

## 寄存器无法寻址，是因为：

1. 寄存器是 CPU 内部的存储单元，没有像内存那样具有线性地址空间。
2. 每个寄存器都有一个固定的名称（例如，eax, ebx, ecx 等），CPU 通过这些名称来访问它们。这种**直接的访问形式**保证了寄存器访问的高效性。如果寄存器可以通过内存地址访问，那么这种速度优势就会丧失。
3. 指令集架构 (ISA) 定义了 CPU 如何执行指令，包括如何访问寄存器和内存。大多数 ISA 都设计成通过寄存器名称而不是内存地址来访问寄存器。

## 不能绑定到临时数据

~~~cpp
int n = 100, m = 200;
int *p1 = &(m + n);    // m + n = 300 
int *p2 = &(n + 100);  // n + 100 的结果为 200 无地址
bool *p4 = &(m < n);   // m < n 的结果为 false 无地址
~~~

这个数值存在于寄存器或者是栈中的临时空间，临时空间没有地址。这些临时值通常是右值，只能在赋值运算符右边。
~~因为这些表达式的结果都会放到寄存器中，以上编译都是错的~~。

还有函数的返回值：

~~~cpp
int func(){
    int n = 100;
    return n;
}
int *p = &(func());
~~~

无法编译是因为 `func()` 的返回值是一个右值 (rvalue)，而 `&` 运算符需要一个左值 (lvalue) 作为操作数。**右值表示一个临时值，它没有稳定的内存地址，因此你无法获取它的地址**。也没法用`&`获取地址。下列表达式是编译错误的。

一般情况下，你无法直接获取函数返回值的地址，因为返回值通常是临时存储的，其生命周期仅限于函数调用结束之前。


## 什么样的临时数据会放到内存中

寄存器离 CPU 近，并且速度比内存快，将临时数据放到寄存器是为了加快程序运行。但是寄存器的数量是非常有限的，容纳不下较大的数据，因此只能将较小的临时数据放在寄存器中。

`int、double、bool、char` 等基本类型的数据往往不超过 8 个字节，用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；而对象、结构体变量是自定义类型的数据，大小不可预测，所以这些类型的临时数据通常会放到内存中。

下面的代码是正确的，它证明了结构体类型的临时数据会被放到内存中： 

~~~cpp
#include <iostream>
using namespace std;
typedef struct{
    int a;
    int b;
} AB;

AB operator+(const AB &A, const AB &B){
    AB C;
    C.a = A.a + B.a;
    C.b = A.b + B.b;
    return C;
}
AB func(){
    AB a;
    a.a = 100;
    a.b = 200;
    return a;
}
int main(){
    AB s1 = {23, 45};
    AB s2 = {90, 75};
    AB *ptr = &s1;      // pass, struct 被放在了内存中 s1 ***
    AB *p1 = &(s1 + s2); // 临时变量 error: taking address of rvalue
    AB *p2 = &(func());  // 临时变量 error: taking address of rvalue
    cout<<p1<<", "<<p2<<endl;
}
~~~

## 常量表达式 不能被寻址

诸如 100、200+34、34.5*23、3+7/3 等不包含变量的表达式称为常量表达式（Constant expression）。

常量表达式由于不包含变量，**没有不稳定因素，所以在编译阶段就能求值**。编译器不会分配单独的内存来存储常量表达式的值，**而是将常量表达式的值和代码合并到一起**，放到虚拟地址空间中的代码区。从汇编的角度看，常量表达式的值就是一个**立即数**，会被**硬编码**到指令中，**不能寻址**。***

~~~cpp
int *p2 = &(23 + 45 * 2);  // 试图给常量表达式寻址
~~~

常量表达式根据编译器的行为不同，可能在代码区，也可能在内存中。而且编译器会对常量表达式进行优化，常量折叠。

constexpr 关键字可以用来强制编译器在编译时对表达式进行求值，从而提高程序的性能。constexpr 特指常量表达式。

## 引用不能指代临时数据

引用和指针在本质上是一样的，引用仅仅是对指针进行了简单的封装。引用和指针都不能绑定到无法寻址的临时数据，并且 C++ 对引用的要求更加严格，在某些编译器下甚至连放在内存中的临时数据都不能指代。

总之记住，不能用引用指代临时数据，下面代码就犯错了(编译时 错误检查阶段就不能通过)：

~~~cpp
// 试图用引用指代临时变量
int m = 100, n = 36;
int &r1 = m + n;
int &r2 = m + 28;
int &r3 = 12 * 3;
int &r4 = 50;
~~~
