## 函数传参

参数的传递本质上是一次复制操作，就是对内存进行一次拷贝。内存拷贝就是将一块内存中的数据拷贝到另一块内存中。

对于向 `char int float` 等基本数据类型，他们占用的内存只有几个字节，对他们进行内存拷贝非常快。而对于数组、结构体、对象等一些列数据的集合，其包含的数据量没有限制，可能很少，也可能成千上万。对他们进行频繁的内存拷贝是效率低的。***

c/c++ 禁止在函数调用时直接传递数组内容，而是**强制传递数组指针**。当你将数组名作为参数传递给函数时，编译器会将它转换为指向数组第一个元素的指针。所以传入的不是数组的副本而是指向数组第一个元素的指针。

`sizeof(arr)`，返回 `arr` 总长度的字节数，因为 `sizeof` 是运算符，不是函数。

当你使用 & 运算符获取数组的地址时，它会返回指向整个数组的指针，而不是指向数组首元素的指针。 这种指针的类型是 `数组类型 (*)[数组大小]`。【TODO验证】

而对于结构体和对象没有这个限制，传啥都行。为例提高效率，传递指针吧。

## 引用

C++ 中有另一种比传指针更便捷的方式，即引用。

引用可以看作是数据的一个别名，通过这个数据本身和别名都可以访问到这份数据。

引用必须在定义时就初始化。

~~~cpp
int main() {
    int a = 0;
    int& r = a;
    cout << a << ", " << r << endl;
    cout << &a << ", " << &r << endl;
}
~~~

a 和 r 的内容一样，地址一样，表示同一份数据。因为指的是同一份数据，所以也可以通过引用来修改原始数据内容。如果你**不希望通过引用来修改原数据内容**，在定义时加上 `const`：

~~~cpp
const int& r = a;
int const& r = a;
~~~

## 引用（左值引用，&）

对左值引用的任何操作都直接作用于被引用的对象本身。

~~~cpp
int& plus10(int& r) {
    r += 10;
    return r;
}
~~~

- 返回值 `int&` : 返回**不是一个副本**。而是引用，引用本质上是对象的别名，它直接指向内存中的原始数据。
- `int& r`: 这表示函数接受一个整数的引用作为参数。这意味着函数不会复制传入的整数，而是直接操作原始整数。
- `r += 10;` :将参数 r 的值增加 10。由于 r 是一个引用，这直接修改了传入函数的原始整数的值。
- `return r;` :返回参数 r 的引用。这意味着函数的返回值**仍然指向传入函数的原始对象**。

所以上述函数，会原地修改 r。

~~~cpp
void test_1() {
    int num1 = 10;
    int num2 = plus10(num1); //  num2 获得的是 num1 修改后（+10）的值的一个副本。num2 只是 num1 修改后值的一个副本。修改 num2 不会影响 num1。 ***
}
void test_2() {
    int num1 = 10;
    int& num2 = plus10(num1);  // 声明了一个引用变量 num2，并将其绑定到 plus10 函数的返回值（num1 的引用）。这意味着 num2 成为 num1 的另一个名称（别名）。 num1 和 num2 指向同一个内存地址。 修改 num2 将直接修改 num1 的值 ***
}
void test_3() {
    int num1 = 10;
    int& num2 = plus10(num1) + 2;  //  编译错误，引用不能引用一个 字面值（右值）。具体讲：plus10(num1) + 2 : 这里，我们对 plus10(num1) 的返回值（一个左值引用）进行加法运算 + 2。 C++ 中，对左值引用进行算术运算会创建一个临时变量（临时对象），该临时变量的值是 20 + 2 = 22。 这个临时变量是一个右值。 ***
}
~~~


## 引用 作为函数的参数

在定义或声明函数时，可以将函数的形参指定为引用形式，这样在函数被调用时，会将**实参和形参绑定在一起**，让他们指代同一份数据。如此一来，如果在函数体中修改了形参的数值，那么实参的数值也会被修改。（回忆以前见到的函数，传递引用）

比如交换两个数的值

按引用传参在使用形式上比指针更加直观。在以后的 C++ 编程中，鼓励大量使用引用，它一般可以代替指针（当然指针在C++中也不可或缺），C++ 标准库也是这样做的。


## 引用 作为函数的返回值

如下例子：

~~~cpp
#include <iostream>
using namespace std;

int& plus10(int& r) {
    r += 10;
    return r;
}
int test_plus_10() {
    int num1 = 10;
    int& num2 = plus10(num1);  // 关键点在于 num2 现在也成为了 num1 更新后的别名。它们指向同一个内存位置。
    cout << num1 << " " << num2 << endl;
    return 0;
}
~~~

结果：20，20

注意，**不能返回局部数据的引用**，以为当函数调用完毕后，局部数据会被销毁。因为函数是在栈上运行的，并且运行结束后会放弃对所有局部数据的管理权，你不知道这个局部数据会被改为什么。*** 这是绝对要避免的。


## 使用左值引用，避免新内存的创建

左值引用是指对一个左值进行引用的引用类型，使用 & 符号声明，可以修改所引用的对象的值。示例代码如下：

~~~cpp
int a = 1;
int& b = a; // b是a的左值引用
b = 2; // 修改b的值，也会修改a的值
~~~

下面 避免了 mem_t 对象的创建，给了个别名，用于后续的参数传递等。避免拷贝。

~~~cpp
const mem_t &src_m = args.find(MY_ARG_SRC);
const mem_t &wei_m = args.find(MY_ARG_WEIGHTS);
const mem_t &bia_m = args.find(MY_ARG_BIAS);
const mem_t &dst_m = args.find(MY_ARG_DST);
~~~


## 返回左值引用的函数可以被赋值吗？

这正是左值引用的意义所在：它允许函数返回对现有对象的引用，从而允许修改该对象。inplace 地修改对象。

~~~cpp
// 返回左值引用，该函数是一个左值
int& func(int& x) {
    return x;
}
int main() {
    int a = 5;
    func(a) = 10; // Yes, a can be assigned a new value through the returned lvalue reference
    cout << a << endl; // Output: 10
    return 0;
}
~~~

`test_plus_10` 是相同的例子。

