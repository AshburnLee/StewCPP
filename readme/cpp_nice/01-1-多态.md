## 多态

多态性质的主要作用是实现基类指针或引用指向派生类对象，从而实现对派生类对象的**统一操作，提高代码的可扩展性和可维护性**。

举例说明：

假设有一个基类 Animal 和两个派生类 Dog 和 Cat ，它们都有一个公共的虚函数 `speak()`，但是每个派生类的 `speak()` 实现不同。

如果我们使用基类指针或引用指向 Dog 或 Cat 对象，然后调用 `speak()` 函数，就可以实现对不同派生类对象的统一操作。

这样，当我们需要添加新的派生类时，只需要继承自 Animal 并实现 `speak()` 函数即可，而不需要修改原有的代码。

以下是示例代码：

~~~cpp
class Animal {  // 接口类
public:
    virtual void speak() = 0; // 纯虚函数
};

class Dog : public Animal {
public:
    void speak() {
        std::cout << "汪汪汪" << std::endl;
    }
};

class Cat : public Animal {
public:
    void speak() {
        std::cout << "喵喵喵" << std::endl;
    }
};

int main() {
    Animal* animal1 = new Dog();
    Animal* animal2 = new Cat();
    animal1->speak(); // 输出：汪汪汪
    animal2->speak(); // 输出：喵喵喵
    delete animal1;
    delete animal2;
    return 0;
}
~~~

- C++ 静态多态，动态多态？

多态性质的主要作用有：

1. 实现接口重用，提高代码的可维护性和可扩展性
2. 简化代码，提高代码的可读性和可理解性
3. 提高代码的灵活性和可复用性，减少代码的重复性
4. 实现运行时多态，使程序更加灵活和可扩展

- 静态多态主要是通过函数重载和运算符重载实现的，编译器在编译时就能确定调用哪个函数或运算符。静态多态可以提高程序的运行效率，但灵活性不如动态多态。
- 动态多态则是通过虚函数实现的，运行时才能确定调用哪个函数。使程序更加灵活和可扩展。


## 父类指针指向子类对象

`class Student : public OOO {}`

这种情况下:

- `OOO *p = new Student("junhui", 157); ` 这里， 即使 `p` 实际指向的是一个 Student 对象，但它毕竟是是一个指向 `OOO` 类的指针，故只能访问 `OOO` 类中定义的成员和方法。因此，p 无法访问 Student 类中特有的方法。记住，你的目的是访问虚函数。【我这么做的目的就是要利用多态】***
- `Student *q = new Student("junhui", 157);` 这里，q 是一个指向 Student 类的指针。由于 q 是 Student 类型的指针，它可以访问 Student 类中定义的所有成员和方法。

## 父类指针指向子类对象时，这个对象是如何在内存中存储的？类对象内存布局

~~~cpp
class OOO {
public:
    OOO() {}

    virtual void DisplayName() { std::cout << "OOO name: " << _name << std::endl; }
    virtual ~OOO() { std::cout << "~OOO \n"; }
    
// private:  //
//     std::string _name; // 

// _name 成员变量只定义一次，在基类 OOO 中。 Student 类通过基类的构造函数来初始化 _name，避免了重复定义和内存浪费。 将 _name 的访问权限设置为 protected，允许派生类访问，同时保持其对外部的隐藏性。
protected:
    std::string _name; 

};

class Student : public OOO {
public:
    Student(const std::string& name) : _name(name) {}
    ~Student() { std::cout << "~Student \n"; }

    virtual void DisplayName() { std::cout << "Student name: " << _name << std::endl; }
// private: // 浪费
//     std::string _name; // 浪费
};
~~~

**子类的内存布局**包括：

- 基类的成员变量 + 基类的虚函数表指针（vtable pointer）（如果有）
- 子类的成员变量
- padding，以满足内存对齐的要求，提高内存访问效率。

可能如下：
+-----------------+
| vptr            |  // 虚函数表指针【只有类对象中才有vptr】
+-----------------+
| OOO::_name      |  // OOO 类的 _name 成员变量
+-----------------+
| Padding         |  // 可能的填充字节
+-----------------+
| Student::_name  |  // Student 类的 _name 成员变量
+-----------------+

编译器处理 `OOO *p = new Student("junhui");`，有一些动作：

1. 按照类的继承关系和成员变量的声明顺序来布局对象的内存： 基类的成员变量 + **虚函数表指针**会首先布局 + 然后是派生类的成员变量。
2. 如果类中有虚函数，编译器会为**每个类**生成一个虚函数表（vtable）存在于类的 metadata（数据段，metadata 包含了指向数据段和代码段中相关部分的指针或偏移量）中，metadata中包含该类的**虚函数指针（不是虚函数表指针，而是虚函数的地址）**。***
3. 当父类指针指向子类对象时，编译器会进行类型转换。由于子类对象的内存布局中包含基类部分（见1），父类指针可以正确地指向子类对象的父类的部分。


**类对象内存布局** 和 **类的元数据** 是两个不同的概念。但是相关。

- 类对象内存布局：对象在内存中的存储。
- 类的元数据：是编译器为每一个类维护的数据结构，包含这个类的信息。
- 虚函数表（vtable）：是编译器为了支持多态而维护的一种数据结构。每个含有虚函数的类都有一个虚函数表（vtable），表中存储的是虚函数指针。每个对象包含一个指向这个类的 vtable pointer(vptr)。

所以**类的 vtable 存在于类的元数据**中，而 **vptr 类实例的内存布局中**。是这样的关系。***


##  C++ 的对象析构顺序遵循

- 最派生类优先： 首先调用的是最派生类（most derived class）的析构函数。 最派生类是指创建对象时使用的实际类型。 如果你使用 `new Derived()` 创建对象，那么 `Derived` 就是最派生类。
- 成员对象**逆序**析构： 接下来，按照成员对象（member objects）在类中声明的**逆序**调用它们的析构函数。 成员对象是指作为类的成员变量存在的对象。
- 基类**逆序**析构： 最后，按照继承列表中基类的**逆序**调用它们的析构函数。 继承列表是指类定义中 `class Derived : public Base1, public Base2 { ... };` 这样的列表。 在这个例子中，Base2 的析构函数会先于 Base1 的析构函数被调用。

## 析构函数
 
当父类和子类析构函数都是 virtual 的时候，会先调用 Derived 的析构函数，再调用 Base 的析构函数，是因为 C++ 的对象析构顺序遵循“最派生类优先”的原则。


## 父类指针 animal 调用子类对象如何实现的？

~~~cpp
int main() {
    Animal* animal = new Dog();
    animal->makeSound();
    delete animal; // 注意：这里应该 delete animal，而不是 dog
    return 0;
}
~~~

1. `Animal* animal = new Dog();`
    - `new Dog()`： 首先，使用 `new` 运算符在堆上创建一个 `Dog` 类的对象。 这会在内存中分配足够的空间来存储 `Dog` 对象的所有成员变量，以及一个指向 `Dog` 类的 `vtable` 的 `vptr`。***
    - `Animal* animal = ...;`： 然后，将 `new Dog()` 返回的 `Dog` 对象的地址赋值给一个 `Animal*` 类型的指针 `animal`。 这里发生了向上转型（Upcasting），将 `Dog*` 隐式转换为 `Animal*`。 **`animal` 指针现在指向堆上的 `Dog` 对象。** *** 【需要记住-当 Dog* dog 向上转型为 Animal* animal 时，animal 指针仍然指向同一个 Dog 对象在内存中的起始地址。】

2. `animal->makeSound();`
    - `animal->makeSound()：` 通过 `animal` 指针调用 `makeSound()` 方法。 由于 `makeSound()` 是一个虚函数，编译器会使用**动态绑定**（Dynamic Binding） 来确定实际要调用的函数。
    - 动态绑定的过程：
        1. 获取 `vptr`： 编译器通过 `animal` 指针找到它所指向的对象的 `vptr`。 由于 `animal` 指向的是一个 `Dog` 对象，所以 `vptr` 指向的是 `Dog` 类的 `vtable。`  ***
        2. 查找 `vtable：` 编译器通过 `vptr` 找到 `Dog` 类的 `vtable。`
        3. 查找函数地址： 编译器在 `Dog` 类的 `vtable` 中查找 `makeSound()` 函数的地址。 由于 `Dog` 类重写了 `makeSound()` 函数，`vtable` 中存储的是 `Dog::makeSound()` 的地址。
        4. 调用函数： 编译器使用查找到的地址来调用 `Dog::makeSound()` 函数。

3. delete animal;
    - delete animal;： 使用 delete 运算符释放 animal 指针指向的内存。
    - 重要： 如果 Animal 类的析构函数不是虚函数，那么 delete animal; 只会调用 Animal 类的析构函数，而不会调用 Dog 类的析构函数。 这会导致内存泄漏，因为 Dog 类可能有一些需要在析构函数中释放的资源。
    - 最佳实践： 为了避免内存泄漏，始终将基类的析构函数声明为虚函数。

补充：

## Upcasting

向上转型是多态的基础，向上转型的结果是：父类指针指向子类对象
