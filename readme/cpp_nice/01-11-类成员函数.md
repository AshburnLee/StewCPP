## 编译器帮你实现了的类函数

当定义了一个class，又没有实现任何成员函数时，编译器会为这个class声明6个函数：

- 默认构造函数 (Default Constructor): 
- 复制构造函数 (Copy Constructor): 
- 复制赋值运算符 (Copy Assignment Operator): 
- 移动构造函数 (Move Constructor) (C++11 及以后): 
- 移动赋值运算符 (Move Assignment Operator) (C++11 及以后): 
- 析构函数 (Destructor): 

`= default` 和 `= delete` 关键字可以用来显式地声明默认或删除这些特殊成员函数。***

~~~cpp
class Myclass{
public:
    Myclass(){...}
    Myclass(const Myclass& rhs){...} // copy构造函数
    ~Myclass(){...}
    Myclass& operator=(const Myclass& rhs){...} // 就是赋值运算符，copy符号操作符
};

// 实例化这个class，并使用
Myclass e1;       //default 构造函数
Myclass e2(e1);   //copy构造函数
e2=e1;            //copy符号操作符，就是赋值运算符
                  //析构函数
~~~

其中

除非这个class的base class含有 virtual 析构函数，那么编译器给出的析构函数是个 non-virtual 函数。此时这个 class 的虚拟性来自其 base class。

对于构造函数，如果我声明了一个构造函数，那么编译器不再创建 default 构造函数。
copy 构造函数，和 copy 操作符只是单纯的将来源对象的每一个 non-static 成员变量拷贝到目标对象。所以:

`Myclass e2(e1)`

是使用e1的成员变量来初始化e2的成员变量。


##  = delete 和 = default [控制编译器生成特殊成员函数的行为]

这两个是用于显式控制编译器对特殊成员函数（如构造函数、析构函数、拷贝构造函数、移动构造函数、拷贝赋值运算符和移动赋值运算符）行为的两个关键字。

- `= delete` 用于显式地禁用某个函数，使其不可用。防止某些不希望的操作。
- `= default` 用于显式地**要求编译器生成默认的实现**。这通常用于显式地声明你希望使用编译器生成的默认构造函数、析构函数、拷贝构造函数、移动构造函数、拷贝赋值运算符或移动赋值运算符。

KAQ: 类难道不会生成默认的某些成员函数吗？`= default` 是否是多余的？

答：尽管编译器会自动生成一些默认的特殊成员函数，但显式地使用 `= default` 仍然有以下几个好处：

- 你可以显式地声明默认的特殊成员函数，并将其放在 `public`、`protected` 或 `private` 访问控制区域，以控制其访问权限。就是你把控制权从编译器中拿过来了。
- 显式声明意图：使用 `= default` 可以明确地表达你的意图，告诉读者和编译器你希望使用编译器生成的默认实现。这有助于提高代码的可读性和可维护性。
- 防止不必要的删除：在某些情况下，编译器可能不会自动生成默认的特殊成员函数。例如，如果你定义了一个自定义的构造函数，编译器将不会生成默认构造函数。使用 `= default` 可以确保这些函数仍然存在。
- 启用移动语义：在某些情况下，编译器可能不会自动生成移动构造函数和移动赋值运算符。显式地使用 `= default` 可以确保这些函数被生成。

## 区分 移动构造函数 vs. 移动赋值运算符

- 移动构造函数：用于**创建一个新的对象**，并将资源从一个临时对象或即将被销毁的对象转移到新对象中。如 `MySmartPointer p2 = std::move(p1);` 由于 p2 是一个新创建的对象，编译器会选择调用移动构造函数来完成这个初始化过程。
- 移动赋值运算符：用于将资源从一个临时对象或即将被销毁的对象转移到一个**已经存在的对象**中。如 `p3 = std::move(p2);` 调用了移动赋值运算符，因为 p3 已经存在。

