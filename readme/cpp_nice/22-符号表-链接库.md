# 符号表 Symbol Table
## 1. 编译器的符号表：

- 是编译器在编译的过程中会维护一个临时的数据结构，用于记录函数变量类等符号信息来进行**语法语义分析**，**作用域管理**和**类型检查**。
- 它是个临时数结构，**编译后不会直接出现在目标文件或库文件中**（其生命周期仅仅在编译过程）。
- 在编译阶段，编译器会为每个源文件维护一个符号表。

## 2. 目标文件/库文件的符号表：

- 在链接阶段，链接器会维护**一个**符号表，主要目的是支持链接。
- 在生成目标文件（如 ELF 文件）时，编译器会将符号信息写入目标文件的符号表段（如 `.symtab` 和 `.dynsym` 段）。这些符号表用于链接阶段的**符号解析**和**重定位**。
- 使用 `readelf、nm` 读取符号表信息。
- 链接器的符号表会包含目标文件和库文件中的所有全局符号和外部符号。这个符号表通常会保存在目标文件或库文件的符号表段中。
- 目标文件符号表有哪些内容：函数代码，数据段（全局变量，静态变量等变量），资源，重定位信息，导入表和导出表


# 常见问题: 动态链接库 符号找不到？

"未定义符号"（undefined symbol）错误通常发生在**链接阶段**或**运行时**。具体的 `_ZN10__host_std18sycl_host_u_mul_hiEjj` 是一个函数或变量，`libtorch_xpu_ops_sycl_kernels.so` 库中缺少一个名为 `_ZN10__host_std18sycl_host_u_mul_hiEjj` 的符号。

可能的原因：

## 1. 检查这个库的依赖项

`libtorch_xpu_ops_sycl_kernels.so` 可能依赖于其他库，这些库中定义了`_ZN10__host_std18sycl_host_u_mul_hiEjj`符号。使用 `ldd` 检查这个 `.so` 文件的依赖库，确保所有的依赖库正确安装并且路径是正确的：

~~~sh
find / -name libtorch_xpu_ops_sycl_kernels.so
readelf -Ws /localdisk/home/lijunhui/mambaforge/envs/junhui-py310/lib/python3.10/site-packages/torch/lib/libtorch_xpu_ops_sycl_kernels.so > libtorch.txt
# found "UND _ZN10__host_std18sycl_host_u_mul_hiEjj" 表示这个库文件依赖这个符号，但是没有找到该符号

ldd /localdisk/home/lijunhui/mambaforge/envs/junhui-py310/lib/python3.10/site-packages/torch/lib/libtorch_xpu_ops_sycl_kernels.so
        linux-vdso.so.1 (0x00007ffd3abdf000)
        libsycl-preview.so.7 => /opt/intel/oneapi/compiler/2024.1/lib/libsycl-preview.so.7 (0x00007fa067620000)  # should have this
        libstdc++.so.6 => /lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007fa0673eb000)
        libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007fa067304000)
        libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007fa0672e2000)
        libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fa0670b9000)
        libdl.so.2 => /lib/x86_64-linux-gnu/libdl.so.2 (0x00007fa0670b4000)
        libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007fa0670af000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fa0e36a0000)  # 动态链接器，作为可执行文件存在于指定库的依赖中
~~~

确保所有依赖都存在且正常

## 2. 环境变量（如`LD_LIBRARY_PATH`）没有正确设置

~~~sh
echo $LD_LIBRARY_PATH | tr ':' '\n'
/opt/intel/oneapi/tbb/2021.12/env/../lib/intel64/gcc4.8
/opt/intel/oneapi/pti/0.9/lib
/opt/intel/oneapi/mkl/2025.0/lib
/opt/intel/oneapi/dpl/2022.5/lib
/opt/intel/oneapi/debugger/2024.1/opt/debugger/lib
/opt/intel/oneapi/compiler/2024.1/opt/oclfpga/host/linux64/lib
/opt/intel/oneapi/compiler/2024.1/opt/compiler/lib
/opt/intel/oneapi/compiler/2024.1/lib  # should have this
~~~

## 3. 这个符号是否存在于某个动态库中

~~~sh
nm -A /opt/intel/oneapi/compiler/2024.1/lib/* | grep _ZN10__host_std18sycl_host_u_mul_hiEjj  # 这将搜索指定目录中的所有库文件，查找包含该符号的文件

nm: /opt/intel/oneapi/compiler/2024.1/lib/libsycl-native-bfloat16.spv: file format not recognized
/opt/intel/oneapi/compiler/2024.1/lib/libsycl-preview.so:0000000000177000 T _ZN10__host_std18sycl_host_u_mul_hiEjj
/opt/intel/oneapi/compiler/2024.1/lib/libsycl-preview.so.7:0000000000177000 T _ZN10__host_std18sycl_host_u_mul_hiEjj
/opt/intel/oneapi/compiler/2024.1/lib/libsycl-preview.so.7.1.0:0000000000177000 T _ZN10__host_std18sycl_host_u_mul_hiEjj
/opt/intel/oneapi/compiler/2024.1/lib/libsycl.so:000000000016fc60 T _ZN10__host_std18sycl_host_u_mul_hiEjj
/opt/intel/oneapi/compiler/2024.1/lib/libsycl.so.7:000000000016fc60 T _ZN10__host_std18sycl_host_u_mul_hiEjj
/opt/intel/oneapi/compiler/2024.1/lib/libsycl.so.7.1.0:000000000016fc60 T _ZN10__host_std18sycl_host_u_mul_hiEjj
nm: /opt/intel/oneapi/compiler/2024.1/lib/libsycl.so.7.1.0-gdb.py: file format not recognized
#

objdump -t /opt/intel/oneapi/compiler/2024.1/lib/* | grep _ZN10__host_std18sycl_host_u_mul_hiEjj
readelf -Ws /opt/intel/oneapi/compiler/2024.1/lib/* | grep _ZN10__host_std18sycl_host_u_mul_hiEjj
# 符号表中的索引号: 符号的地址 符号的大小(byte) 是个函数 全局的 默认绑定 符号在section中的索引 符号名
  3283: 0000000000177000    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  5923: 0000000000177000    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  3283: 0000000000177000    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  5923: 0000000000177000    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  3283: 0000000000177000    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  5923: 0000000000177000    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  3280: 000000000016fc60    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  5899: 000000000016fc60    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  3280: 000000000016fc60    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  5899: 000000000016fc60    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  3280: 000000000016fc60    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
  5899: 000000000016fc60    13 FUNC    GLOBAL DEFAULT   12 _ZN10__host_std18sycl_host_u_mul_hiEjj
~~~

如果是从源代码编译这些库，可能是**编译选项不正确**，导致某些符号没有被正确导出。
PyTorch 和 SYCL **库的版本不匹配**，导致某些符号在新版本中不存在或被修改。


# 更多关于 DLL，Symbol，Symbol Table

DLL 是包含可以由多个程序同时使用的代码和数据的文件。可以在**运行时**被**多个程序加载和使用**。

~~~sh
libsycl-preview.so
libsycl-preview.so.7
libsycl-preview.so.7.1.0
~~~

KAQ: 上述 3 者之间是什么关系？答：文件系统中实际上是这样的:

~~~sh
libsycl-preview.so -> libsycl-preview.so.7
libsycl-preview.so.7 -> libsycl-preview.so.7.1.0
libsycl-preview.so.7.1.0
~~~

只有最长的那个是实际库文件，另外两个是符号链接。

- 符号（Symbol）是编译器和链接器用来**标识**程序中的变量、函数等实体的名称。
- 符号表（Symbol Table）是一个数据结构，存储了这些符号及其相关信息，如地址、类型等。**链接器**和加载器使用符号表来解析符号。
- `ELF` 文件格式的灵活性和广泛支持使其成为现代操作系统中处理可执行文件和库的标准格式。
- `readelf` 作用是 Display information about the contents of ELF format files. 其结果中出现 `UND` 表示这个符号是**当前库所依赖的但未定义**的符号，会在运行时由链接器解析。
- `ldd`（list dynamic dependencies）命令用于显示可执行文件或共享库的动态依赖关系。它会列出程序或库**所依赖**的所有共享库，并显示这些库的路径。
- `LD_LIBRARY_PATH` 是一个环境变量，用于指定**动态链接器在查找共享库时应该搜索的目录**。它的值是一个以冒号分隔的目录列表。
- `nm` 只列出 dll 中的所符号，全称 name mangling
- `objdump` 显示ELF文件的汇编代码、符号表、重定位信息等。

~~~sh
# 查看这个dll中符号表
readelf -Ws /opt/intel/oneapi/compiler/2024.1/lib/libsycl-preview.so.7
# 查看这个dll中的指定符号
readelf -Ws /opt/intel/oneapi/compiler/2024.1/lib/libsycl-preview.so.7 | grep _ZN10__host_std18sycl_host_u_mul_hiEjj

# 只列出dll中的所符号
nm /home/lijunhui/workspace/intel-xpu-backend-for-triton/python/triton/_C/libGPUHello.so
# 反汇编得到 ELF 文件汇编
objdump -d /opt/intel/oneapi/compiler/2024.1/lib/libsycl-preview.so.7
~~~

## `ldd` 和 `LD_LIBRARY_PATH` 之间的关系：

1. 当一个程序运行时，动态链接器会根据一系列规则**查找它所依赖**的共享库。`LD_LIBRARY_PATH` 是这些规则中的一部分(第一个规则)。
2. `ldd` 使用 `LD_LIBRARY_PATH`：当你使用 `ldd` 命令来查看一个可执行文件或共享库的依赖关系时，`ldd` 会**模拟动态链接器的行为**，包括使用 `LD_LIBRARY_PATH` 环境变量来查找共享库。因此，如果你设置了` LD_LIBRARY_PATH`，`ldd` 命令的输出会反映这些路径。

## 当 ldd 发现库有的依赖路径不是期望的，如何处理

`ldd my_exe` 返回 `libtest.so => /bushi/.../build/libtest.so`。 这个路径是不对的，找到正确的路径，然后更新 `LD_LIBRARY_PATH` 即可：

~~~sh
find ./ -name libtest.so
export LD_LIBRARY_PATH=<your build path>:${LD_LIBRARY_PATH}
~~~

## 动态链接器 ld.so & ld-linux.so

我有一个动态库 `libfoo.so` （`g++ -fPIC -shared foo.cpp -o libfoo.so`），并且编译出了可执行文件 `main`（`g++ main.cpp -L. -lfoo -o main`），当你运行 `./main` 时，动态链接器（如 `ld.so` 或 `ld-linux.so`）会执行以下步骤：

- 加载可执行文件：动态链接器加载可执行文件 `main`，并解析其 `ELF` 头部信息。
- 解析动态段找到所需要的共享库：动态链接器解析可执行文件的动态段（`.dynamic`），找到需要加载的共享库（如 `libfoo.so`）。
- 加载共享库：动态链接器根据动态段中的信息，加载共享库 `libfoo.so` 到内存中。
- 符号解析 和 重定位：动态链接器解析可执行文件和共享库中的符号，并进行符号重定位。确保可执行文件中的符号引用指向共享库中的实际地址。之后才是执行
- 执行共享库的初始化代码：动态链接器执行共享库的初始化代码（如构造函数）。
- 开始执行程序：动态链接器**将控制权交给可执行文件的 `main` 函数**，开始执行程序。

所以在可执行文件被执行时，其实是动态链接器先干活，最后交给可执行文件。

## 为什么 ldd 显示动态链接器

ldd 显示动态链接器的原因是为了提供完整的**动态依赖关系图**，包括程序在运行时所需的所有共享库和动态链接器。动态链接器是程序运行时必不可少的一部分。

动态链接器在 Linux 系统中确实是一个可执行文件，但它的名字和路径看起来像一个共享库文件。这种设计原因：

- 历史原因：保持与早期 UNIX 系统的兼容性
- 技术原因：动态链接器需要在程序启动时被操作系统加载，并负责加载和链接其他共享库。将动态链接器设计为一个特殊的可执行文件，可以简化操作系统的加载过程。

`readelf -l ./main | grep 'interpreter'` 所示：
`[Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]`

这行输出显示了动态链接器的路径。

如上述，ldd 模拟了动态连接器的行为，所以它水首先找到系统中的动态连接器。


## LD_LIBRARY_PATH  [DLL的搜索路径]

是一个环境变量，用于指定共享库（动态链接库）的搜索路径。当应用程序在运行时需要加载动态链接库时，系统将根据 `LD_LIBRARY_PATH` 中指定的路径进行搜索。

以下是关于 `LD_LIBRARY_PATH` 的一些相关信息：

1. 功能：`LD_LIBRARY_PATH` 环境变量用于告诉**动态链接器（ld.so）**在程序加载时搜索共享库的路径。
2. 搜索顺序：动态链接器按照 `LD_LIBRARY_PATH` 中定义的路径的顺序搜索共享库。它会首先搜索 `LD_LIBRARY_PATH` 中第一个路径下的共享库，然后**依次按顺序**搜索下一个路径。
3. 路径分隔符：`LD_LIBRARY_PATH` 是由冒号（:）分隔的路径列表。在 UNIX/Linux 系统上，路径之间使用冒号进行分隔；在 Windows 系统上，路径之间使用分号进行分隔。
4. 优先级：`LD_LIBRARY_PATH` 中的路径**优先于**系统默认的共享库路径。这意味着如果 `LD_LIBRARY_PATH` 中的路径中包含了与系统默认路径中相同名称的共享库，系统将优先加载 `LD_LIBRARY_PATH` 中的共享库。
5. 设置或添加库路径到此路径 ： `export LD_LIBRARY_PATH=<your buildf path>:${LD_LIBRARY_PATH}`

注意：`LD_LIBRARY_PATH`是一种临时修改共享库搜索路径的方法。
如果要在系统级别设置共享库路径，应该考虑更稳定和可靠的方法，如使用共享库配置文件（如 /etc/ld.so.conf）或通过使用 rpath 或运行时链接器标志等。


## PATH  [可执行文件的搜索路径]

这里是可执行文件的搜索路径，将你的 命令所在路径添加到PATH，调用命令时就不需要提供完整的路径了。为当前 用户永久添加：写入 `~/.bashrc` 为所有用户提供这个路径，你可以编辑 `/etc/profile` 或 `/etc/environment` 文件中的 PATH



## 符号链接 = 符号解析 + 符号绑定

~~~cpp
#include <iostream>

void my_func() {}

int main() {
    my_func();
    std::cout << "hello" << std::endl;
}
~~~

在进行符号链接时，仍然有两个主要的步骤：

- 符号解析（Symbol Resolution）： 在符号解析阶段，编译器会**查找 my_func 和 std::cout 的定义位置**。对于 my_func，它会在同一源文件中找到其定义。对于 std::cout，它是 iostream 库的一部分，编译器会在相应的库文件中找到其定义。

- 符号绑定（Symbol Binding）： 在符号绑定阶段，编译器将 my_func 和 std::cout 的符号**引用**与**其定义**进行绑定。对于源文件中的 my_func，**编译器将其替换为对应的函数定义**。对于 std::cout，编译器会将其与 iostream 库中的定义进行关联。

