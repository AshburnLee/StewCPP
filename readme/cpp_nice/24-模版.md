

# 模板 Template

模板是 C++ 中实现泛型编程的一种具体机制。它允许程序员定义函数或类时不指定具体的类型（编写时类型无关），而是**使用占位符（称为模板参数），表示可以是任何类型**，在编译时由编译器根据**实际使用情况**生成具体代码。模板是 C++ 语言中的一个语法工具。

模板的例子：

~~~cpp
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    int x = add(1, 2);         // 使用 int
    double y = add(3.14, 2.86); // 使用 double
    return 0;
}
~~~

编译时发生什么？

  - 模板定义：程序员写的 `add` 是类型无关的，`T` 是一个占位符。
  - 模板实例化：编译器看到 `add(1, 2)` 和 `add(3.14, 2.86)`，分别生成两份代码：
      - `int add(int a, int b) { return a + b; }`
      - `double add(double a, double b) { return a + b; }`
  - 编译器会自动推导类型，也可以手动指明
  - 运行时执行：程序运行时，直接调用这些类型特定的函数，没有任何运行时的类型推导或动态分派。

所以 模板是 编写时类型无关；编译时类型特化；运行时类型相关。

# 编译时类型检查

# 模板编程中两种重要的形式
## 1. 函数模板

编写与类型无关的函数，编译时根据代码生成类型相关的函数。上述 add 函数就是。给出另一个实例：

我的一个 kernel，支持多种拷贝函数：
~~~cpp
template <cpy_kernel_t cpy_1>
__global__ void cpy_flt(/* 参数 */) {
    // ...
    cpy_1(src_ptr, dst_ptr);  // 这里调用
}
~~~

~~~cpp
// 1. 定义函数指针类型
typedef void (*cpy_kernel_t)(const char *, char *);

// 2. 定义你支持的拷贝函数
static __device__ void cpy_1_f32(const char * src, char * dst) {
    *(float*)dst = *(const float*)src;
}
static __device__ void cpy_1_f16(const char * src, char * dst) {
    *(half*)dst = *(const half*)src;
}

// 3. 调用你的kernel时，传入具体的拷贝函数
cpy_flt<cpy_1_f32><<<blocks, threads>>>(...);  // 生成 float 版本
cpy_flt<cpy_1_f16><<<blocks, threads>>>(...);  // 生成 half 版本
~~~

编译器看到最后两行时，会在编译时生成完全独立的两个kernel（两个kernel的名称由编译器决定，是nm之后的名字）


## 2. 类模板

类模板用于定义可以适用于多种数据类型的类。
