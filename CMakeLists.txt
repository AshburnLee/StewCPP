## 1. cmake version
cmake_minimum_required(VERSION 3.5)

if(NOT CMAKE_VERSION VERSION_LESS 3.0)
    message(STATUS "cmake version: ${CMAKE_VERSION}")
else()
    message(STATUS "low verion of cmake")
endif()

## 2. project name
project(MYCPP)
set(CMAKE_CXX_STANDARD 14)

# -Wall 表示显示warning
# add_compile_options(-Wall -Wextra -pedantic -Werror)
# add_compile_options(-Wall)

## 3. build type, 使用默认的编译器版本或者cmake时用户指定
if(NOT DEFINED STEWCPP_COMPILER)
    set(STEWCPP_COMPILER "g++")
endif()
set(CMAKE_CXX_COMPILER "${STEWCPP_COMPILER}")
message("cxx compiler: ${STEWCPP_COMPILER}")

if(NOT DEFINED STEWC_COMPILER)
    set(STEWC_COMPILER "gcc")
endif()
set(CMAKE_C_COMPILER "${STEWC_COMPILER}")
message("c compiler: ${STEWC_COMPILER}")

# set(CMAKE_CXX_COMPILER "g++")
set(CMAKE_CXX_FLAGS "-Wall")  # 开启所有警告

set(CMAKE_BUILD_TYPE Debug)


# if(CMAKE_CUDA_COMPILER)
#     message("GPU platform detected")
#     # add_definitions(-DPLATFORM=GPU)
#     set(MY_PLATFORM CUDA)
# elseif(CMAKE_CXX_COMPILER)
#     message("CPU platform detected")
#     # add_definitions(-DPLATFORM=cpu)
#     set(MY_PLATFORM CPU)
# endif()
# add_definitions(-DPLATFORM=MY_PLATFORM)

# 或者
# if(CMAKE_CUDA_COMPILER)
#     message("GPU platform detected")
#     add_definitions(-DPLATFORM=GPU)
# elseif(CMAKE_CXX_COMPILER)
#     message("CPU platform detected")
#     add_definitions(-DPLATFORM=CPU)
# endif()




## 4. 添加header path
message("--- include_directories")
message("current path: ${CMAKE_CURRENT_SOURCE_DIR}")
# 文件系统，将以下文件夹 放入变量 HEADER_MYCPP
# file(GLOB_RECURSE HEADER_MYCPP .. )
file(GLOB HEADER_MYCPP
    ${CMAKE_CURRENT_SOURCE_DIR}/headers/algos
    ${CMAKE_CURRENT_SOURCE_DIR}/headers/algos/sort
    ${CMAKE_CURRENT_SOURCE_DIR}/headers/utils
    ${CMAKE_CURRENT_SOURCE_DIR}/headers/grammer
    ${CMAKE_CURRENT_SOURCE_DIR}/headers/self
    ${CMAKE_CURRENT_SOURCE_DIR}/headers/meta)
# 用于指定编译器的头文件搜索路径，具体是将这些头文件目录添加到编译器的搜索路径中，
# 使得编译器在编译源码时可以找到并包含这些头文件，而不需要手动指定每个头文件的路径。
include_directories(${HEADER_MYCPP}) 
# 定义函数
function(show_header_path)
    foreach(header ${HEADER_MYCPP})
        message("headers: ${header}")
    endforeach()
endfunction()
# 函数调用
show_header_path() 





message("--- generate executables")
## 添加可执行文件
# add_executable(main.out ./source/main.cpp)
# add_executable(class_size.out ./source/class_size.cpp)
# add_executable(copy_constructor.out ./source/copy_constructor.cpp)
# add_executable(friends.out ./source/friends.cpp)
# add_executable(copy_deep.out ./source/copy_deep.cpp)
# add_executable(overload_assignment.out ./source/overload_assignment.cpp)
# add_executable(overload.out ./source/overload.cpp)
# add_executable(static_class.out ./source/static_class.cpp)
# add_executable(overload_math.out ./source/overload_math.cpp)
# add_executable(overload_subscriptor.out ./source/overload_subscriptor.cpp)
# add_executable(void_ptr.out ./source/void_ptr.cpp)
# add_executable(this_ptr.out ./source/this_ptr.cpp)
# add_executable(type_convertion_func.out ./source/type_convertion_func.cpp)
# add_executable(inherit.out ./source/inherit.cpp)
# add_executable(lambda.out ./source/lambda.cpp)
# add_executable(enclosed_class.out ./source/enclosed_class.cpp)
# add_executable(memory_in_c.out ./source/memory_in_c.cpp)
# add_executable(compile_function.out ./source/compile_function.cpp)
# add_executable(referrence.out ./source/referrence.cpp)
# add_executable(cpp11.out ./source/cpp11.cpp)

# generated by ChatGPT:

# 这段代码用于自动编译多个源文件并生成对应的可执行文件。
# 首先，它使用file函数获取source目录下所有的.cpp文件，并将它们保存在一个列表中。
file(GLOB SOURCE_FILES "./source/*.cpp")
# 然后，它使用foreach循环遍历列表中的每个源文件，使用get_filename_component函数获取源文件的文件名（不包括扩展名），
# 并将其作为可执行文件的名称
foreach(SOURCE_FILE ${SOURCE_FILES})
    get_filename_component(EXECUTABLE_NAME ${SOURCE_FILE} NAME_WE)
    # 最后，它使用add_executable函数将源文件编译成可执行文件。
    set(NEW_NAME "${EXECUTABLE_NAME}.junhui")
    add_executable(${NEW_NAME} ${SOURCE_FILE})

    # 添加全局宏定义
    # 这段代码根据 PLATFORM 变量的值，使用 target_compile_definitions 命令定义 PLATFORM 宏。
    set(PLATFORM "CPU" CACHE STRING "Select platform (CPU or CUDA)")
    if(PLATFORM STREQUAL "CUDA")
        target_compile_definitions(${NEW_NAME} PRIVATE PLATFORM=CUDA)
    elseif(PLATFORM STREQUAL "CPU")
        target_compile_definitions(${NEW_NAME} PRIVATE PLATFORM=CPU)
    else()
        message(FATAL_ERROR "Unknown platform: ${PLATFORM}")
    endif()

endforeach()
